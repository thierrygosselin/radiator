# Import, filter and transform a dart output file to different formats

#' @name filter_dart

#' @title Swiss Army knife tool to prepare \href{http://www.diversityarrays.com}{DArT}
#' output file for population genetics analysis.

#' @description Import, filter and generate imputed datasets of DArT output file.
#' The function uses \code{\link[radiator]{tidy_dart}} to import and tidy DArT input file.
#' Currently 3 formats are recognized: 1- and 2- row format (also called binary),
#' and count data.


#' @param interactive.filter (optional, logical) Do you want the filtering session to
#' be interactive. The user is asked to see figures of distribution before
#' making decisions for filtering. If you opt for this, fill the arguments:
#' \code{data, strata, output},
#' optionally fill these ones \code{pop.levels, blacklist.id, pop.select,
#' monomorphic.out, common.markers}, the rest are not necessary.
#' Default: \code{interactive.filter = TRUE}.

#' @inheritParams tidy_dart
#' @inheritParams genomic_converter
#' @inheritParams tidy_genomic_data


#' @param strata A tab delimited file or object with 3 columns.
#' Columns header is:
#' \code{TARGET_ID}, \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals.
#' You need to make sure that
#' the column \code{TARGET_ID} match the id used by DArT.
#' The column \code{INDIVIDUALS} and \code{STRATA} will be kept in the tidy data.
#' Only individuals in the strata file are kept in the tidy, i.e. that the strata
#' is also used as a whitelist of individuals/strata.


#' @param filter.reproducibility (optional, numerical) Filter the \code{RepAvg}
#' column in the data set. For DArT this is the proportion of technical
#' replicate assay pairs for which the marker score is consistent.
#' Default: \code{filter.reproducibility = NULL}.
#' e.g to keep markers with reproducibility >= 99%,
#' use: \code{filter.reproducibility = 0.99}.

#' @param filter.call.rate (optional, numerical) Filter the \code{CallRate}
#' column in the data set. For DArT this is the proportion of samples for
#' which the genotype was called. Default: \code{filter.call.rate = NULL}. e.g to keep
#' markers genotyped in more than 95% of the individuals use :
#' \code{filter.call.rate = 0.95}

#' @param filter.markers.coverage (optional, string, numerical) Filter the lower and
#' upper bound of locus/read coverage. The locus/read coverage combines the markers
#' average count for REF and ALT allele (respectively the \code{AvgCountRef} and
#' \code{AvgCountSnp} info). These markers statistics are generated by DArT.
#' If you have count data, use \code{erase.genotypes} argument below instead.
#' Default: \code{filter.markers.coverage = NULL}.
#' e.g to keep markers with coverage inbetween 7 and 200,
#' use : \code{filter.markers.coverage = c(7, 200)}.

#' @param erase.genotypes (optional, string, numerical) DArT file with count
#' data is required for this argument to work. With count data, genotype,
#' REF and ALT coverage information is available and is better suited than
#' \code{filter.markers.coverage} to remove/erase data based on coverage info.
#' This function argument requires 3 values in the string:
#' \enumerate{
#' \item threshold.low.coverage: threshold for the minimum read coverage. Under this threshold,
#' genotypes are erased. e.g. 7
#' \item threshold.gl: threshold that applies only for heterozygous genotypes.
#' Using the \code{threshold.low.coverage} doesn't guarantees that REF and ALT
#' allele have adequate coverage. This threshold does.
#' A genotype likelihood value is generated based
#' on the departure of equal coverage between REF and ALT allele, number of samples
#' sharing the heterozygous genotype for the locus, missing data for the locus
#' and individual. Below the genotype likelihood threshold value,
#' the heterozygous genotypes are erased. e.g. if an heterozygous genotype for a
#' marker as REF/ALT coverage of 100/3 with only 1 sample sharing this info and
#' this sample has 50% missing data and the marker missingness is averaged, the
#' GL value will be extremely low compared to another heterozygous genotype with
#' 50/50 of coverage and 10 samples sharing the same genotype...
#' \item threshold.high.coverage: threshold that allows to erase genotypes with
#' very high coverage
#' }
#' e.g. of values: \code{erase.genotypes = c(7, -0.25, 200)}.
#' However, using the \code{interactive.filter = TRUE} is highly recommended to
#' visualize data before choosing values.
#' Default: \code{erase.genotypes = NULL}.

#' @param filter.individuals.missing (optional, double) New argument to blacklist
#' individuals with too many missing genotypes. Below the threshold, individuals
#' are blacklisted. e.g. 0.80 will blacklist individuals with more than 20% missing
#' genotypes.
#' Default: \code{filter.individuals.missing = NULL}.


#' @param filter.markers.missing (optional, string) Similar to call rate, but
#' more adapted to the data. 3 values are required in the string, corresponding
#' to the \code{\link[radiator]{filter_individual}} module of radiator.
#' First value is the approach to count genotyped individuals per markers, \code{"overall"}
#' or by \code{"pop"}. Second value is the percent threshold for the marker, with
#' \code{70}, 70 percent of genotyped individuals are required to keep the marker.
#' The last threshold is the number of problematic population that are allowed to skip
#' the threshold. In doubt, use the interactive mode that take step by step these
#' arguments. e.g to keep individuals genotyped at >= 70 percent for the markers,
#' without considering the population info and allowing 1 population to be problematic for the
#' threshold, use: \code{c("overall", 70, 1)}.
#' Default: \code{filter.markers.missing = NULL}.


#' @param number.snp.reads (optional, integer) This filter removes outlier markers
#' with too many SNP number per locus/read.
#' Having a higher than "normal" SNP number is usually the results of
#' assembly artifacts or bad assembly parameters.
#' This filter is population-agnostic. This is best decide after viewing the figures,
#' with the interactive mode.
#' If the argument is set to \code{number.snp.reads = 2},
#' locus with 3 and more SNPs will be blacklisted.
#' Default: \code{number.snp.reads = NULL}.

#' @param mixed.genomes.analysis (optional, logical) Highlight outliers individual's
#' observed heterozygosity for a quick
#' diagnostic of mixed samples or poor polymorphism discovery due to DNA quality,
#' sequencing effort, etc.
#' See this function for more info: \code{\link[radiator]{detect_mixed_genomes}}.
#' Default: \code{detect_mixed_genomes = TRUE}.

#' @inheritParams detect_mixed_genomes

#' @param duplicate.genomes.analysis (optional, string) Detect duplicate individuals.
#' The function can compute two methods (distance or genome pairwise similarity)
#' to highligh potential duplicate individuals.
#' See this function for more info: \code{\link[radiator]{detect_duplicate_genomes}}.
#' The string required to run the analysis as 2 values:
#' \enumerate{
#' \item TRUE/FALSE to run the analysis;
#' \item Computes pairwise genome similarity (TRUE/FALSE),
#' with FALSE just the distance measure is used.
#' The pairwise genome similarity is longer to run, but is better because it
#' integrates markers in common/missing data.
#' Using \code{interactive.filter = TRUE}, can overide this value,
#' you can opt in for the pairwise genome similarity after viewing the figures
#' used with distance measure... handy!
#' }
#' Default: \code{detect_duplicate_genomes = c(TRUE, FALSE)}.

#' @inheritParams filter_hwe

#' @param filename (optional) The filename prefix for the objet in the global environment
#' or the working directory. Default: \code{filename = NULL}. A default name will be used,
#' customized with the output file(s) selected.

#' @param ... (optional) To pass further argument for fine-tuning the function.

#' @note
#' The function requires 2 packages (not installed automatically with radiator):
#' \itemize{
#' \item HardyWeinberg: to filter markers in HWD
#' \item ggtern: to generate ternary graph
#' }

#' @return The function returns an object (list). The content of the object
#' can be listed with \code{names(object)} and use \code{$} to isolate specific
#' object (see examples). Some output format will write the output file in the
#' working directory. The tidy genomic data frame is generated automatically.

#' @export
#' @rdname filter_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom stats IQR

#' @examples
#' \dontrun{
#' require(HardyWeinberg)
#' require(ggtern)
#' #TODO
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

filter_dart <- function(
  interactive.filter = TRUE,
  data,
  strata,
  output = NULL,
  pop.levels = NULL,
  blacklist.id = NULL,
  pop.select = NULL,
  monomorphic.out = TRUE,
  common.markers = TRUE,
  filter.reproducibility = NULL,
  filter.call.rate = NULL,
  filter.markers.coverage = NULL,
  erase.genotypes = NULL,
  filter.individuals.missing = NULL,
  filter.markers.missing = NULL,
  maf.thresholds = NULL,
  number.snp.reads = NULL,
  snp.ld = "maf",
  mixed.genomes.analysis = TRUE,
  ind.heterozygosity.threshold = NULL,
  duplicate.genomes.analysis = c(TRUE, FALSE),
  hw.pop.threshold = 0,
  midp.threshold = "****",
  imputation.method = NULL,
  hierarchical.levels = "strata",
  num.tree = 50,
  filename = NULL,
  verbose = TRUE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {

  # testing
  # interactive.filter = TRUE
  # # data
  # # strata
  # # output = NULL
  # pop.levels = NULL
  # blacklist.id = NULL
  # pop.select = NULL
  # monomorphic.out = TRUE
  # common.markers = TRUE
  # filter.reproducibility = NULL
  # filter.call.rate = NULL
  # filter.markers.coverage = NULL
  # erase.genotypes = NULL
  # filter.individuals.missing = NULL
  # filter.markers.missing = NULL
  # maf.thresholds = NULL
  # number.snp.reads = NULL
  # snp.ld = "maf"
  # mixed.genomes.analysis = TRUE
  # ind.heterozygosity.threshold = NULL
  # duplicate.genomes.analysis = c(TRUE, FALSE)
  # hw.pop.threshold = 0
  # midp.threshold = "****"
  # imputation.method = NULL
  # hierarchical.levels = "strata"
  # num.tree = 50
  # filename = NULL
  # verbose = TRUE
  # parallel.core = parallel::detectCores() - 1


  if (!requireNamespace("HardyWeinberg", quietly = TRUE)) {
    stop("HardyWeinberg package needed for this function to work
         Install with install.packages('HardyWeinberg')", call. = FALSE)
  }

  if (!requireNamespace("ggtern", quietly = TRUE)) {
    stop("ggtern package needed for this function to draw ternary plots
         Install with install.packages('ggtern')", call. = FALSE)
  }

  if (verbose) {
    cat("#######################################################################\n")
    cat("######################## radiator::filter_dart ########################\n")
    cat("#######################################################################\n")
  }
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()# for timing
  res <- list()

  # dotslist -------------------------------------------------------------------
  dotslist <- list(...)
  want <- c("filter.coverage", "filter.ind.missing.geno")
  unknowned_param <- setdiff(names(dotslist), want)

  if (length(unknowned_param) > 0) {
    stop("Unknowned \"...\" parameters ",
         stringi::stri_join(unknowned_param, collapse = " "))
  }

  radiator.dots <- dotslist[names(dotslist) %in% want]
  filter.coverage <- radiator.dots[["filter.coverage"]]
  filter.ind.missing.geno <- radiator.dots[["filter.ind.missing.geno"]]

  if (!is.null(filter.coverage) && !is.null(filter.ind.missing.geno)) {
    stop("
         filter.coverage is deprecated in favour of: filter.markers.coverage
         filter.ind.missing.geno is deprecated in favour of: filter.markers.missing")
  }

  if (!is.null(filter.coverage)) {
    stop("
         filter.coverage is deprecated in favour of: filter.markers.coverage")
  }

  if (!is.null(filter.ind.missing.geno)) {
    stop("
         filter.ind.missing.geno is deprecated in favour of: filter.markers.missing")
  }


  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")

  # Filename -------------------------------------------------------------------
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")

  if (is.null(filename)) {
    folder.extension <- filename <- stringi::stri_join("filter_dart_", file.date)
  } else {
    folder.extension <- stringi::stri_join("filter_dart", filename, file.date, sep = "_")
    filename <- stringi::stri_join(filename, file.date, sep = "_")
  }

  working.dir <- getwd()
  path.folder <- stringi::stri_join(working.dir,"/", folder.extension, sep = "")
  dir.create(file.path(path.folder))

  message("\nFolder created: \n", folder.extension)
  filename <- file.path(path.folder, filename)

  # File type ------------------------------------------------------------------
  data.type <- radiator::detect_genomic_format(data)

  if (data.type == "dart") {
    # Check that DArT file as good target id written
    target.id <- extract_dart_target_id(data, write = FALSE)
    if (nrow(target.id) != length(unique(target.id$TARGET_ID))) {
      stop("non unique target id are used in the DArT file...
           What you want are different target ids at the end of the row that
           contains AlleleID, AlleleSequence, etc.
           The columns headers.
           Edit manually before trying again
           If you're still encountering problem, email author for help")
    }
    target.id <- NULL
  }

  if (data.type == "fst.file") {
    message("Importing tidy DArT data...")
    input <- radiator::read_rad(data)
  }

  # Filter parameter file ------------------------------------------------------
  filters.parameters.path <- stringi::stri_join(
    path.folder, "/filters_parameters_dart.tsv")
  filters.parameters <- tibble::data_frame(
    FILTERS = as.character(),
    PARAMETERS = as.character(),
    VALUES = as.integer(),
    BEFORE = as.character(),
    AFTER = as.character(),
    BLACKLIST = as.integer(),
    UNITS = as.character(),
    COMMENTS = as.character()) %>%
    readr::write_tsv(
      x = .,
      path = filters.parameters.path,
      append = FALSE,
      col_names = TRUE)
  message("Generated a filters parameters file: filters_parameters_dart.tsv")

  # Markers meta----------------------------------------------------------------
  metadata <- radiator::tidy_dart_metadata(
    data = data,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = TRUE)

  # metadata.file <- list.files(path = path.folder, pattern = "metadata")

  # create 2 data.info
  data.info <- first.data.info <- data_info(metadata, print.info = FALSE)

  #1.Filtering reproducibility  -------------------------------------------------
  if (interactive.filter || !is.null(filter.reproducibility)) {
    if (verbose) cat("\n### 01: Filtering markers reproducibility #############################\n")
    folder.extension <- stringi::stri_join("01_filter_reproducibility_", file.date, sep = "")
    path.folder.reproducibility <- file.path(path.folder, folder.extension)
    dir.create(path.folder.reproducibility)
    message("Folder created: ", folder.extension)

    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REP_AVG")
    reproducibility <- dplyr::select(metadata, dplyr::one_of(want)) %>%
      dplyr::mutate(Markers = rep("markers", n()))

    outlier.rep <- stats::quantile(reproducibility$REP_AVG, 0.25, na.rm = TRUE) -
      (1.5 * stats::IQR(reproducibility$REP_AVG, na.rm = TRUE))

    plot.reproducibility.violinplot <- ggplot2::ggplot(
      reproducibility, ggplot2::aes(x = Markers, y = REP_AVG, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                            size = 2.5, fill = "white") +
      ggplot2::labs(
        x = "Markers",
        y = "Markers reproducibility averaged",
        title = "DArT reproducibility stats",
        subtitle = stringi::stri_join(
          "outlier lower bound: ", outlier.rep)) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_blank()
      )
    # plot.reproducibility.violinplot
    ggplot2::ggsave(
      filename = file.path(path.folder.reproducibility, "plot.reproducibility.violinplot.pdf"),
      plot = plot.reproducibility.violinplot,
      width = 20, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE)

    plot.reproducibility.histo <- ggplot2::ggplot(
      data = reproducibility,
      ggplot2::aes(x = REP_AVG)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(
        x = "Markers",
        y = "Markers reproducibility averaged",
        title = "DArT reproducibility stats",
        subtitle = stringi::stri_join(
          "outlier lower bound: ", outlier.rep)) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.reproducibility.histo
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.reproducibility, "plot.reproducibility.histo.pdf"),
      plot = plot.reproducibility.histo,
      width = 20, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))

    if (interactive.filter) {
      suppressWarnings(print(plot.reproducibility.histo))
      suppressWarnings(print(plot.reproducibility.violinplot))
      message("    Inspect plots to help choose reproducibility threshold...")
      message("    Enter the threshold value (between 0 and 1)")
      message("    below threshold < markers are discarded)")
      filter.reproducibility <- interactive_question(
        x = "Enter value: ", minmax = c(0, 1))
      # filter.reproducibility <- as.numeric(readLines(n = 1))
    }

    if (!is.null(filter.reproducibility)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")

      blacklist.reproducibility.markers <- reproducibility %>%
        dplyr::filter(REP_AVG < filter.reproducibility) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      if (nrow(blacklist.reproducibility.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.reproducibility.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

        metadata <- metadata %>%
          dplyr::filter(!MARKERS %in% blacklist.reproducibility.markers$MARKERS)

        new.data.info <- data_info(metadata) # updating parameters

        filters.parameters <- tibble::data_frame(
          FILTERS = "reproducibility",
          PARAMETERS = "",
          VALUES = filter.reproducibility,
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        blacklist.markers <- blacklist.reproducibility.markers
        whitelist.markers <- dplyr::select(metadata, MARKERS, CHROM, LOCUS, POS)

        # write blacklist and whitelist
        readr::write_tsv(x = blacklist.reproducibility.markers, path = file.path(path.folder.reproducibility, "blacklist.reproducibility.markers.tsv"))
        readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.reproducibility, "whitelist.reproducibility.markers.tsv"))

      }
      blacklist.markers <- blacklist.reproducibility.markers <- NULL
      whitelist.markers <- dplyr::select(metadata, MARKERS, CHROM, LOCUS, POS)
    } else {
      stop("A filter.reproducibility threshold value is required...")
    }

    reproducibility <- plot.reproducibility.histo <- NULL
    outlier.rep <- plot.reproducibility.violinplot <- NULL
  }#End filter.reproducibility

  #2.Filtering call rate ---------------------------------------------------------
  if (interactive.filter || !is.null(filter.call.rate)) {
    if (verbose) cat("\n### 02: Filtering markers call rate ###################################\n")

    folder.extension <- stringi::stri_join("02_filter_call_rate_", file.date, sep = "")
    path.folder.call.rate <- file.path(path.folder, folder.extension)
    dir.create(path.folder.call.rate)
    message("Folder created: \n", folder.extension)

    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "CALL_RATE")
    call.rate <- dplyr::select(metadata, dplyr::one_of(want)) %>%
      dplyr::mutate(Markers = rep("markers", n()))

    median.cr <- round(stats::median(call.rate$CALL_RATE, na.rm = TRUE), 2)
    q25 <- round(stats::quantile(call.rate$CALL_RATE, 0.25, na.rm = TRUE), 2)
    outlier.cr <- round(q25 - (1.5 * stats::IQR(call.rate$CALL_RATE, na.rm = TRUE)), 2)

    plot.call.rate.violinplot <- ggplot2::ggplot(
      call.rate, ggplot2::aes(x = Markers, y = CALL_RATE, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21, size = 2.5, fill = "white") +
      ggplot2::labs(
        x = "Markers",
        y = "Markers Call Rate (proportion)",
        title = "DArT Call Rate stats",
        subtitle = stringi::stri_join(
          "median: ", median.cr,
          "    outlier lower bound: ", outlier.cr, "    quantile 0.25: ", q25)) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_blank()
      )
    # plot.call.rate.violinplot
    ggplot2::ggsave(
      filename = file.path(path.folder.call.rate, "plot.call.rate.violinplot.pdf"),
      plot = plot.call.rate.violinplot,
      width = 20, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE)

    plot.call.rate.histo <- ggplot2::ggplot(
      data = call.rate,
      ggplot2::aes(x = CALL_RATE)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(
        x = "Markers",
        y = "Markers Call Rate (proportion)",
        title = "DArT Call Rate stats",
        subtitle = stringi::stri_join(
          "median: ", median.cr,
          "    outlier lower bound: ", outlier.cr, "    quantile 0.25: ", q25)) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.call.rate.histo
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.call.rate, "plot.call.rate.histo.pdf"),
      plot = plot.call.rate.histo,
      width = 20, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))

    if (interactive.filter) {
      print(plot.call.rate.histo)
      print(plot.call.rate.violinplot)
      message("    Inspect plots in folder created to help choose call rate threshold...")
      message("    Enter the value (between 0 and 1) for filter.call.rate threshold \n    (below threshold < markers are discarded): ")
      # filter.call.rate <- as.numeric(readLines(n = 1))
      filter.call.rate <- interactive_question(
        x = "Enter value: ", minmax = c(0, 1))

    }

    if (!is.null(filter.call.rate)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.call.rate.markers <- call.rate %>%
        dplyr::filter(CALL_RATE < filter.call.rate) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      if (nrow(blacklist.call.rate.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.call.rate.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

        # input <- dplyr::anti_join(input, blacklist.call.rate.markers, by = "MARKERS")

        metadata <- metadata %>%
          dplyr::filter(!MARKERS %in% blacklist.call.rate.markers$MARKERS)

        new.data.info <- data_info(metadata) # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "call rate",
          PARAMETERS = "",
          VALUES = filter.call.rate,
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        )
        readr::write_tsv(x = filters.parameters,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.call.rate.markers)
        } else {
          blacklist.markers <- blacklist.call.rate.markers
        }

        whitelist.markers <- dplyr::select(metadata, dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE)

        # write blacklist and whitelist
        readr::write_tsv(x = blacklist.call.rate.markers, path = file.path(path.folder.call.rate, "blacklist.call.rate.markers.tsv"))
        readr::write_tsv(x = whitelist.markers, path = file.path(path.folder.call.rate, "whitelist.call.rate.markers.tsv"))
      }
      blacklist.call.rate.markers <- NULL
    } else {
      stop("A filter.call.rate threshold value is required...")
    }
    call.rate <- plot.call.rate.histo <- plot.call.rate.violinplot <- NULL
    outlier.cr <- median.cr <- q25 <- NULL
  }#End filter.call.rate

  # strata, pop.levels, pop.labels, pop.select and blacklist.id ----------------
  if (verbose) cat("\n#######################################################################\n")
  message("\nPre-analyzing the strata file...")
  strata.df <- radiator::read_strata(
    strata = strata,
    pop.levels = pop.levels, pop.labels = NULL,
    pop.select = pop.select, blacklist.id = blacklist.id,
    keep.two = FALSE, verbose = FALSE)
  pop.levels <- strata.df$pop.levels
  pop.labels <- strata.df$pop.labels
  pop.select <- strata.df$pop.select
  blacklist.id <- strata.df$blacklist.id
  strata.df <- strata.df$strata

  data.info$n.pop <- first.data.info$n.pop <- dplyr::n_distinct(strata.df$STRATA)
  data.info$n.ind <- first.data.info$n.ind <- dplyr::n_distinct(strata.df$INDIVIDUALS)
  metadata <- NULL
  # Tidy DArT ------------------------------------------------------------------
  message("\nNext step requires the genotypes")
  if (data.type == "dart") {
    input <- radiator::tidy_dart(
      data = data, strata = strata.df,
      whitelist.markers = whitelist.markers,
      filename = filename, verbose = TRUE,
      parallel.core = parallel.core,
      tidy.output = "light")

  } else {
    input <- input %>%
      dplyr::filter(MARKERS %in% whitelist.markers$MARKERS) %>%
      dplyr::filter(INDIVIDUALS %in% strata.df$INDIVIDUALS)
  }
  # strata.df <- NULL
  # Make sure unnecessary columns are removed
  want <- c("CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE", "REP_AVG")
  input <- suppressWarnings(dplyr::select(input, -dplyr::one_of(want)))

  # clean...
  input$INDIVIDUALS <- radiator::clean_ind_names(input$INDIVIDUALS)

  # Change populations names or order/levels -----------------------------------
  if (is.factor(input$POP_ID)) input$POP_ID <- droplevels(input$POP_ID)
  pop.levels <- levels(input$POP_ID)
  input <- change_pop_names(data = input, pop.levels = pop.levels)

  # check for count data
  count.data <- tibble::has_name(input, "ALLELE_REF_DEPTH")

  # Update data info
  data.info$n.pop <- dplyr::n_distinct(input$POP_ID)
  data.info$n.ind <- dplyr::n_distinct(input$INDIVIDUALS)

  #3.Filter monomorphic markers  ------------------------------------------------
  if (monomorphic.out) {
    if (verbose) cat("\n### 03: Filtering monomorphic markers #################################\n")
    folder.extension <- stringi::stri_join("03_filter_monomorphic_markers_", file.date, sep = "")
    path.folder.mono <- file.path(path.folder, folder.extension)
    dir.create(path.folder.mono)
    message("Folder created: \n", folder.extension)

    input <- discard_monomorphic_markers(data = input, verbose = verbose)
    blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
    whitelist.markers <- input$whitelist.polymorphic.markers
    input <- input$input

    # update blacklist.markers
    if (nrow(blacklist.monomorphic.markers) > 0) {
      readr::write_tsv(x = blacklist.monomorphic.markers,
                       path = file.path(path.folder.mono, "blacklist.monomorphic.markers.tsv"))
      if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

      if (is.null(blacklist.markers)) {
        blacklist.markers<- blacklist.monomorphic.markers
      } else {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
      }

      new.data.info <- data_info(input)
      if (count.data) {
        new.data.info$n.chrom <- data.info$n.chrom
        new.data.info$n.locus <- NA_integer_
        n.locus.after <- "NA"
        bl.locus <- "NA"
      } else {
        n.locus.after <- new.data.info$n.locus
        bl.locus <- data.info$n.locus - n.locus.after
      }

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "removing monomorphic markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, n.locus.after, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, bl.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.mono, "tidy.data.monomorphic.rad"))
      message("File written: tidy.data.monomorphic.rad")
    }
    blacklist.monomorphic.markers <- NULL
  }# End monomorphic.out

  #4.Filter common markers between all populations  -----------------------------
  if (common.markers) {
    if (verbose) cat("\n### 04: Filtering common markers ######################################\n")
    folder.extension <- stringi::stri_join("04_filter_common_markers_", file.date, sep = "")
    path.folder.common <- file.path(path.folder, folder.extension)
    dir.create(path.folder.common)
    message("Folder created: \n", folder.extension)

    input <- keep_common_markers(data = input, plot = FALSE,
                                 verbose = verbose)
    blacklist.not.in.common.markers <- input$blacklist.not.in.common.markers
    whitelist.markers <- tibble::as_data_frame(input$whitelist.common.markers) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.common, "whitelist.common.markers.tsv"))

    if (file.exists(file.path(getwd(), "whitelist.common.markers.tsv"))) {
      file.remove(file.path(getwd(), "whitelist.common.markers.tsv"))
    }
    input <- input$input

    if (nrow(blacklist.not.in.common.markers) > 0) {
      readr::write_tsv(x = blacklist.not.in.common.markers,
                       path = file.path(path.folder.common, "blacklist.not.in.common.markers.tsv"))
      if (verbose) message("    File written: blacklist.not.in.common.markers.tsv")

      new.data.info <- data_info(input) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "keeping common markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(
          blacklist.markers,
          blacklist.not.in.common.markers)
      } else {
        blacklist.markers <- blacklist.not.in.common.markers
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.common, "tidy.data.common.markers.rad"))
      message("File written: tidy.data.common.markers.rad")
    }
    blacklist.not.in.common.markers <- NULL
  } #End common.markers

  #5.Filtering coverage --------------------------------------------------------
  if (!is.null(erase.genotypes) || !is.null(filter.markers.coverage) || interactive.filter) {
    if (verbose) cat("\n### 05: Filtering coverage ############################################\n")
    folder.extension <- stringi::stri_join("05_filter_coverage_", file.date, sep = "")
    path.folder.coverage <- file.path(path.folder, folder.extension)
    dir.create(path.folder.coverage)
    message("Folder created: ", folder.extension)
  }
  if (!count.data && (interactive.filter || !is.null(filter.markers.coverage))) {
    message("Filtering markers mean coverage")
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "AVG_COUNT_REF", "AVG_COUNT_SNP")
    coverage <- suppressWarnings(dplyr::select(input, dplyr::one_of(want)) %>%
                                   dplyr::rename(REF = AVG_COUNT_REF, ALT = AVG_COUNT_SNP) %>%
                                   dplyr::distinct(MARKERS, REF, ALT, .keep_all = TRUE) %>%
                                   dplyr::mutate(READS = REF + ALT))

    coverage.long <- tidyr::gather(data = coverage,
                                   key = GROUP,
                                   value = COVERAGE, -MARKERS) %>%
      dplyr::mutate(GROUP = factor(GROUP, levels = c("READS", "REF", "ALT"), ordered = TRUE))
    plot.coverage <- ggplot2::ggplot(
      data = coverage.long,
      ggplot2::aes(x = COVERAGE)) +
      ggplot2::geom_histogram() +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Coverage (count)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) +
      ggplot2::facet_grid(~ GROUP)
    # plot.coverage
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.coverage.pdf"),
      plot = plot.coverage,
      width = 30, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))

    plot.coverage.boxplot <- ggplot2::ggplot(
      coverage.long,
      ggplot2::aes(x = factor(GROUP), y = COVERAGE, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21, size = 2.5, fill = "white") +
      ggplot2::labs(x = "Markers") +
      ggplot2::labs(y = "Coverage (count)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
        legend.title = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      )
    # plot.coverage.boxplot
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.coverage.boxplot.pdf"),
      plot = plot.coverage.boxplot,
      width = 15, height = 15, dpi = 600, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))

    if (interactive.filter) {
      filter.coverage <- c(1, 1000000)
      message("    Inspect plots in folder created to help choose coverage thresholds (min and max)...")
      message("    Enter the minimum coverage allowed to keep a marker (e.g. 7)")
      # filter.coverage[1] <- as.numeric(readLines(n = 1))
      filter.coverage[1] <- interactive_question(
        x = "Enter value: ", minmax = c(0, 10000000))
    }

    if (interactive.filter) {
      message("    Enter the maximum coverage allowed to keep a marker (e.g. 150): ")
      # filter.coverage[2] <- as.numeric(readLines(n = 1))
      filter.coverage[2] <- interactive_question(
        x = "Enter value: ", minmax = c(0, 10000000))
      filter.coverage <- as.numeric(filter.coverage)
    }

    if (!is.null(filter.coverage)) {
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.coverage.markers <- suppressWarnings(
        coverage %>%
          dplyr::filter(READS < filter.coverage[1] | READS > filter.coverage[2]) %>%
          dplyr::select(dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE))

      if (nrow(blacklist.coverage.markers) > 0) {
        n.snp.before <- data.info$n.snp
        if (verbose) message("    Number of markers before = ", n.snp.before)
        n.snp.blacklist <- nrow(blacklist.coverage.markers)
        if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
        if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)
        # input <- dplyr::anti_join(input, blacklist.coverage.markers, by = "MARKERS")

        input <- input %>%
          dplyr::filter(!MARKERS %in% blacklist.coverage.markers$MARKERS)

        whitelist.markers <- suppressWarnings(
          dplyr::select(input, dplyr::one_of(want)) %>%
            dplyr::distinct(MARKERS, .keep_all = TRUE))

        new.data.info <- data_info(input) # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "coverage",
          PARAMETERS = "min/max",
          VALUES = stringi::stri_join(filter.coverage, collapse = "/"),
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(
            x = .,
            path = filters.parameters.path, append = TRUE,
            col_names = FALSE)
        # update data.info
        data.info <- new.data.info

        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers,
                                                blacklist.coverage.markers)
        } else {
          blacklist.markers <- blacklist.coverage.markers
        }

        # write blacklist and whitelist
        readr::write_tsv(
          x = blacklist.coverage.markers,
          path = file.path(path.folder.coverage, "blacklist.coverage.markers.tsv"))
        readr::write_tsv(
          x = whitelist.markers,
          path = file.path(path.folder.coverage, "whitelist.coverage.markers.tsv"))
      }
    } else {
      stop("A filter.coverage thresholds values are required...")
    }
    blacklist.coverage.markers <- coverage <- coverage.long <- plot.coverage <- plot.coverage.boxplot <- NULL
    message("File written: tidy.data.coverage.rad")
    radiator::write_rad(data = input, path = file.path(path.folder.coverage, "tidy.data.coverage.rad"))
    message("File written: tidy.data.coverage.rad")
  } else {# Counts data
    # Filter low genotypes coverage
    message("Filtering genotypes coverage")

    if (!is.null(erase.genotypes)) {
      threshold.low.coverage <- erase.genotypes[1]
      threshold.gl <- erase.genotypes[2]
      threshold.high.coverage <- erase.genotypes[3]
    }

    #1. Filter low and high coverage for all genotypes with read depth ---------
    message("1. Genotypes coverage: low and high read depth")
    message("    generating plot...")
    cov_stats <- function(x, cov.filter = NULL) {
      x <- x[x>0 & !is.na(x)]

      if (!is.null(cov.filter)) {
        x <- x[x > cov.filter[1] & x < cov.filter[2]]
      }

      res <- tibble::data_frame(
        MEAN = mean(x, na.rm = TRUE),
        MEDIAN = stats::median(x, na.rm = TRUE),
        SD = stats::sd(x, na.rm = TRUE),
        Q25 = stats::quantile(x, 0.25, na.rm = TRUE),
        Q75 = stats::quantile(x, 0.75, na.rm = TRUE),
        IQR = stats::IQR(x, na.rm = TRUE),
        MIN = min(x, na.rm = TRUE),
        MAX = max(x, na.rm = TRUE),
        OUTLIERS_LOW = Q25 - (1.5 * IQR),
        OUTLIERS_HIGH = Q75 + (1.5 * IQR),
        OUTLIERS_LOW_N = length(x[x < OUTLIERS_LOW]),
        OUTLIERS_HIGH_N = length(x[x > OUTLIERS_HIGH]),
        OUTLIERS_TOTAL = OUTLIERS_HIGH_N + OUTLIERS_LOW_N,
        OUTLIERS_PROP = round(OUTLIERS_TOTAL / length(x), 3)
      )
      return(res)
    }

    cov.stats <- dplyr::bind_rows(
      tibble::add_column(.data = cov_stats(input$READ_DEPTH), GROUP = "GENOTYPES", FILTER = "with outliers", .before = 1),
      tibble::add_column(.data = cov_stats(input$ALLELE_REF_DEPTH), GROUP = "REF", FILTER = "with outliers", .before = 1),
      tibble::add_column(.data = cov_stats(input$ALLELE_ALT_DEPTH), GROUP = "ALT", FILTER = "with outliers", .before = 1)
    )

    cov.filter <- c(cov.stats$OUTLIERS_LOW[cov.stats$GROUP == "GENOTYPES"],
                    cov.stats$OUTLIERS_HIGH[cov.stats$GROUP == "GENOTYPES"])
    cov.stats <- dplyr::bind_rows(
      cov.stats,
      dplyr::bind_rows(
        tibble::add_column(.data = cov_stats(input$READ_DEPTH, cov.filter = cov.filter), GROUP = "GENOTYPES", FILTER = "without outliers", .before = 1),
        tibble::add_column(.data = cov_stats(input$ALLELE_REF_DEPTH, cov.filter = cov.filter), GROUP = "REF", FILTER = "without outliers", .before = 1),
        tibble::add_column(.data = cov_stats(input$ALLELE_ALT_DEPTH, cov.filter = cov.filter), GROUP = "ALT", FILTER = "without outliers", .before = 1)
      )
    ) %>%
      dplyr::mutate(
        GROUP = factor(GROUP, levels = c("GENOTYPES", "REF", "ALT"),
                       ordered = TRUE),
        FILTER = factor(FILTER, levels = c("with outliers", "without outliers"),
                        ordered = TRUE)
      ) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.coverage,"genotypes.coverage.stats.tsv"))

    element.text <- ggplot2::element_text(size = 10,
                                          family = "Helvetica", face = "bold")
    range.with.outliers <- stringi::stri_join("coverage range with outliers: ", "[", cov.stats$MIN[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "with outliers"], " - ", cov.stats$MAX[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "with outliers"], "]")
    range.without.outliers <- stringi::stri_join("coverage range without outliers: ", "[", cov.stats$MIN[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "without outliers"], " - ", cov.stats$MAX[cov.stats$GROUP == "GENOTYPES" & cov.stats$FILTER == "without outliers"], "]")
    data_range <- ggplot2::as_labeller(c(`with outliers` = range.with.outliers, `without outliers` = range.without.outliers))

    plot.coverage.boxplot <- ggplot2::ggplot(
      cov.stats,
      ggplot2::aes(factor(GROUP), na.rm = TRUE)) +
      ggplot2::geom_boxplot(
        ggplot2::aes(ymin = MIN, lower = Q25, middle = MEDIAN, upper = Q75, ymax = MAX), stat = "identity") +
      ggplot2::labs(
        x = "Coverage groups",
        y = "Coverage (read depth)",
        title = "Genotypes coverage information") + #, subtitle = stringi::stri_join("coverage range with outliers: ", range.with.outliers, "\ncoverage range without outliers: ", range.without.outliers)) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
        # plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
        legend.position = "none",
        axis.title.x = element.text,
        axis.title.y = element.text,
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),
        legend.title = element.text,
        legend.text = element.text,
        strip.text.x = element.text
      ) +
      ggplot2::facet_wrap(~FILTER, nrow = 2, ncol = 1, scales = "free", labeller = ggplot2::labeller(FILTER = data_range))
    cov.stats <- range.with.outliers <- range.without.outliers <- data_range <- NULL

    print(plot.coverage.boxplot)
    suppressMessages(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.coverage.boxplot.pdf"),
      plot = plot.coverage.boxplot,
      width = 15, height = 20, dpi = 300, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))
    plot.coverage.boxplot <- NULL

    if (interactive.filter) {
      threshold.low.coverage <- 0
      threshold.high.coverage <- 1000000000
      message("    Inspect plots to help choose min and max coverage threshold")
      message("    Enter the minimum read depth threshold to call a genotype")
      message("    Below this threshold, genotypes are erased (e.g. 10) ")
      threshold.low.coverage <- interactive_question(
        x = "Enter value: ", minmax = c(0, 10000000000))
      # threshold.low.coverage <- as.numeric(readLines(n = 1))
      message("    Enter the maximum read depth threshold to call a genotype")
      message("    Above this threshold, genotypes are erased (e.g. 200) ")
      threshold.high.coverage <- interactive_question(
        x = "Enter value: ", minmax = c(0, 10000000000))
      # threshold.high.coverage <- as.numeric(readLines(n = 1))
    }

    n.genotypes <- length(input$GT_BIN[!is.na(input$GT_BIN)])
    input <- input %>%
      dplyr::mutate(
        BLACKLIST_GENOTYPES_COMMENT = READ_DEPTH < threshold.low.coverage | READ_DEPTH > threshold.high.coverage)
    blacklist.genotypes <- dplyr::filter(input, BLACKLIST_GENOTYPES_COMMENT) %>%
      dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "low or high coverage")
    n.blacklist.genotypes <- nrow(blacklist.genotypes)
    if (n.blacklist.genotypes > 0) {
      message("    number of blacklisted (erased) genotypes (%): ",
              n.blacklist.genotypes, " (",
              round(n.blacklist.genotypes / n.genotypes * 100, 2),")")

      blacklist.genotypes <- blacklist.genotypes %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.coverage, "blacklist.genotypes.tsv")) %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(
          GT_BIN = NA_integer_,
          ALLELE_REF_DEPTH = NA_integer_,
          ALLELE_ALT_DEPTH = NA_integer_,
          READ_DEPTH = NA_integer_)

      input <- input %>%
        dplyr::filter(is.na(READ_DEPTH) | !BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::bind_rows(blacklist.genotypes)
      blacklist.genotypes <- NULL

      # new.data.info <- data_info(metadata) # updating parameters
      n.genotypes.after <- n.genotypes - n.blacklist.genotypes
      n.genotypes.after.prop <- round(n.genotypes.after / n.genotypes, 2)
      n.blacklist.genotypes.prop <- round(n.blacklist.genotypes / n.genotypes, 2)
      filters.parameters <- tibble::data_frame(
        FILTERS = "low or high coverage",
        PARAMETERS = "min/max",
        VALUES = stringi::stri_join(threshold.low.coverage, threshold.high.coverage, sep = "/"),
        BEFORE = n.genotypes,
        AFTER = paste(n.genotypes.after, " (", n.genotypes.after.prop, ")", sep = ""),
        BLACKLIST = paste(n.blacklist.genotypes, " (", n.blacklist.genotypes.prop, ")", sep = ""),
        UNITS = "genotypes (prop)",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
    } else {
      n.genotypes.after <- n.genotypes
    }

    # 2. het genotypes coverage ------------------------------------------------
    # escape a bit the first threshold
    # second pass of filtering using alleles coverage info
    # using the same threshold we explore the data.
    if (interactive.filter) {
      message("2. Heterozygous genotypes coverage: REF/ALT alleles below ", threshold.low.coverage, " reads")
      message("   Generating Heterozygous genotypes statistics ...")
    }
    gl_relative <- function(x) x / max(x)

    input <- suppressWarnings(
      radiator::write_rad(data = input, path = file.path(path.folder.coverage, "temp.coverage.rad")) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::mutate(
          GENOTYPED_PROP_MARKERS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
        ) %>%
        dplyr::group_by(INDIVIDUALS) %>%
        dplyr::mutate(
          GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
        ) %>%
        dplyr::ungroup(.) %>%
        dplyr::filter(
          GT_BIN == 1,
          ALLELE_REF_DEPTH <= threshold.low.coverage | ALLELE_ALT_DEPTH <= threshold.low.coverage) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::mutate(NUMBER_INDIVIDUALS = length(INDIVIDUALS)) %>%
        dplyr::ungroup(.) %>%
        dplyr::mutate(
          ALLELE_RATIO_LIK = ALLELE_ALT_DEPTH / ALLELE_REF_DEPTH,
          ALLELE_RATIO_LIK = dplyr::if_else(ALLELE_RATIO_LIK > 1, 1 / ALLELE_RATIO_LIK, ALLELE_RATIO_LIK)
        ) %>%
        dplyr::mutate_at(
          .tbl = .,
          .vars = c("NUMBER_INDIVIDUALS", "GENOTYPED_PROP_MARKERS", "GENOTYPED_PROP_INDIVIDUALS"),
          .funs = gl_relative) %>%
        dplyr::mutate(
          # GT_BIN = factor(GT_BIN),
          # Different weight
          # Very primitive GL but really works well
          # Note to myself: z-score could also be used and explored here
          # similar to AMOVA with missing
          GL = ((ALLELE_RATIO_LIK * 4) +# The ratio between REF and ALT x4
                  (NUMBER_INDIVIDUALS * 3) +# The number of individuals with same genotypes x3
                  (GENOTYPED_PROP_INDIVIDUALS * 2) +# The number of individuals with same genotypes x3
                  GENOTYPED_PROP_MARKERS) / 10 # the proportion of genotypes within markers x1
        ) %>%
        dplyr::mutate_at(
          .tbl = .,
          .vars = "GL",
          .funs = gl_relative) %>%
        dplyr::select(MARKERS, INDIVIDUALS, GT_BIN, READ_DEPTH, ALLELE_REF_DEPTH,
                      ALLELE_ALT_DEPTH, GL, NUMBER_INDIVIDUALS,
                      GENOTYPED_PROP_MARKERS, GENOTYPED_PROP_INDIVIDUALS) %>%
        dplyr::mutate(GL = log10(GL)) %>%
        dplyr::arrange(GL))

    plot.gl.violinplot <- input %>%
      dplyr::select(GT_BIN, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH, GL) %>%
      data.table::as.data.table(.) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = c("GT_BIN", "GL"),
        variable.name = "ALLELES",
        value.name = "READ_DEPTH"
      ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::filter(READ_DEPTH <= threshold.low.coverage)

    min.rd <- min(plot.gl.violinplot$READ_DEPTH)
    max.rd <- max(plot.gl.violinplot$READ_DEPTH)
    overall.range <- stringi::stri_join(min.rd, max.rd, sep = "-")
    overall.levels <- seq(from = min.rd, to = max.rd, by = 1)
    overall.levels <- c(overall.levels, overall.range)
    plot.gl.violinplot$READ_DEPTH <- as.character(plot.gl.violinplot$READ_DEPTH)

    plot.gl.violinplot <- suppressWarnings(
      dplyr::bind_rows(
        plot.gl.violinplot,
        plot.gl.violinplot %>%
          dplyr::mutate(
            ALLELES = rep("OVERALL", n()),
            READ_DEPTH = rep(overall.range, n()))
      ) %>%
        dplyr::mutate(
          ALLELES = factor(
            x = ALLELES,
            levels = c("ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH", "OVERALL"),
            labels = c("REF", "ALT", "OVERALL")),
          READ_DEPTH = factor(x = READ_DEPTH, levels = overall.levels)))

    plot.gl.violinplot <- ggplot2::ggplot(
      plot.gl.violinplot, ggplot2::aes(x = READ_DEPTH, y = GL, na.rm = TRUE)) +
      ggplot2::geom_violin(trim = TRUE) +
      ggplot2::geom_boxplot(width = 0.1, fill = "black", outlier.colour = NA) +
      ggplot2::stat_summary(fun.y = "mean", geom = "point", shape = 21,
                            size = 2.5, fill = "white") +
      ggplot2::labs(x = "Alleles read depth of heterozygous genotypes",
                    y = "Genotype Likelihood (GL)") +
      ggplot2::theme(
        legend.position = "none",
        axis.title.y = element.text,
        axis.title.x = element.text,
        axis.text.x = element.text
      ) +
      ggplot2::facet_wrap(~ ALLELES, scales = "free_x")
    print(plot.gl.violinplot)
    suppressWarnings(ggplot2::ggsave(
      filename = file.path(path.folder.coverage, "plot.gl.violinplot.pdf"),
      plot = plot.gl.violinplot,
      width = length(overall.levels) * 1.8, height = 10, dpi = 300, units = "cm",
      useDingbats = FALSE, limitsize = FALSE))
    plot.gl.violinplot <- NULL

    # GL and coverage correlation statistics------------------------------------
    cor_ref <- function(x) {
      stats::cor.test(~ ALLELE_REF_DEPTH + VALUE, data = x)
    }

    cor_alt <- function(x) {
      stats::cor.test(~ ALLELE_ALT_DEPTH + VALUE, data = x)
    }

    cor.data <- suppressWarnings(
      input %>%
        dplyr::mutate(GENOTYPE = seq(from = 1, to = n(), by = 1)) %>%
        dplyr::select(GENOTYPE, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH,
                      NUMBER_INDIVIDUALS, READ_DEPTH, GENOTYPED_PROP_MARKERS,
                      GENOTYPED_PROP_INDIVIDUALS) %>%
        data.table::as.data.table(.) %>%
        data.table::melt.data.table(
          data = .,
          id.vars = c("GENOTYPE", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH"),
          variable.name = "GROUP",
          value.name = "VALUE"
        ) %>%
        tibble::as_data_frame(.) %>%
        dplyr::select(-GENOTYPE))

    depth.cor <- suppressWarnings(
      cor.data %>%
        dplyr::group_by(GROUP) %>%
        tidyr::nest(.key = DATA) %>%
        dplyr::mutate(
          MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_ref), broom::tidy)
        ) %>%
        tidyr::unnest(MODEL) %>%
        dplyr::select(-DATA)) %>%
      tibble::add_column(.data = ., ALLELE = rep("REF", nrow(.)), .before = 1)
    colnames(depth.cor) <- stringi::stri_trans_toupper(colnames(depth.cor))

    alt.cor <- suppressWarnings(
      cor.data %>%
        dplyr::group_by(GROUP) %>%
        tidyr::nest(.key = DATA) %>%
        dplyr::mutate(
          MODEL = purrr::map(purrr::map(.x = DATA, .f = cor_alt), broom::tidy)
        ) %>%
        tidyr::unnest(MODEL) %>%
        dplyr::select(-DATA)) %>%
      tibble::add_column(.data = ., ALLELE = rep("ALT", nrow(.)), .before = 1)
    colnames(alt.cor) <- stringi::stri_trans_toupper(colnames(alt.cor))
    cor.data <- NULL
    depth.cor <- dplyr::bind_rows(depth.cor, alt.cor)
    alt.cor <- NULL
    # View(depth.cor)
    readr::write_tsv(
      x = depth.cor,
      path = file.path(path.folder.coverage, "het.geno.correlation.tsv"))
    depth.cor <- NULL

    if (interactive.filter) {
      threshold.gl <- -1000000
      message("    Enter the gl threshold (close to 0 the better)")
      message("    Below this threshold, heterozygous genotypes are erased: ")
      # threshold.gl <- as.double(readLines(n = 1))
      threshold.gl <- interactive_question(
        x = "Enter value: ", minmax = c(-1, 0))
    }

    blacklist.genotypes.gl <- dplyr::select(input, MARKERS, INDIVIDUALS, GL) %>%
      dplyr::filter(GL < threshold.gl) %>%
      dplyr::distinct(MARKERS, INDIVIDUALS) %>%
      dplyr::mutate(BLACKLIST_GENOTYPES_COMMENT = "bad.gl")
    input <- radiator::read_rad(data = file.path(path.folder.coverage, "temp.coverage.rad"))
    file.remove(file.path(path.folder.coverage, "temp.coverage.rad"))
    n.blacklist.genotypes <- nrow(blacklist.genotypes.gl)

    if (n.blacklist.genotypes > 0) {
      n.genotypes <- n.genotypes.after
      n.blacklist.genotypes.prop <- round(n.blacklist.genotypes / n.genotypes, 6)

      message("    number of blacklisted (erased) genotypes (%): ",
              n.blacklist.genotypes, " (",
              round(n.blacklist.genotypes / n.genotypes * 100, 2),")")

      input <- dplyr::left_join(
        input,
        blacklist.genotypes.gl, by = c("MARKERS", "INDIVIDUALS"))
      blacklist.genotypes.gl <- NULL

      blacklist.genotypes.gl <- dplyr::filter(
        input, BLACKLIST_GENOTYPES_COMMENT == "bad.gl") %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.coverage, "blacklist.genotypes.tsv"),
          append = TRUE) %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::mutate(
          GT_BIN = NA_integer_,
          ALLELE_REF_DEPTH = NA_integer_,
          ALLELE_ALT_DEPTH = NA_integer_,
          READ_DEPTH = NA_integer_
        )

      input <- input %>%
        dplyr::filter(
          is.na(BLACKLIST_GENOTYPES_COMMENT) | BLACKLIST_GENOTYPES_COMMENT != "bad.gl") %>%
        dplyr::select(-BLACKLIST_GENOTYPES_COMMENT) %>%
        dplyr::bind_rows(blacklist.genotypes.gl)
      blacklist.genotypes.gl <- NULL


      # new.data.info <- data_info(metadata) # updating parameters
      n.genotypes.after <- n.genotypes - n.blacklist.genotypes
      n.genotypes.after.prop <- round(n.genotypes.after / n.genotypes, 6)
      filters.parameters <- tibble::data_frame(
        FILTERS = "heterozygous genotypes low gl",
        PARAMETERS = "low gl",
        VALUES = threshold.gl,
        BEFORE = n.genotypes,
        AFTER = paste(n.genotypes.after, " (", n.genotypes.after.prop, ")", sep = ""),
        BLACKLIST = paste(n.blacklist.genotypes, " (", n.blacklist.genotypes.prop, ")", sep = ""),
        UNITS = "genotypes (prop)",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
    }
    element.text <- NULL

    # Write the file
    radiator::write_rad(data = input, path = file.path(path.folder.coverage, "tidy.data.coverage.rad"))
    message("File written: tidy.data.coverage.rad")
  }#End filter coverage counts data

  # remove unnecessary metadata ------------------------------------------------
  if (count.data) {
    radiator::write_rad(
      data = dplyr::select(input, MARKERS, INDIVIDUALS, READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH),
      path = file.path(path.folder, "temp_markers_coverage_info.rad"))
    input <- dplyr::select(input, -c(READ_DEPTH, ALLELE_REF_DEPTH, ALLELE_ALT_DEPTH))
  }

  #6.Filter monomorphic markers  ------------------------------------------------
  if (monomorphic.out) {
    if (verbose) cat("\n### 06: Filtering monomorphic markers #################################\n")
    folder.extension <- stringi::stri_join("06_filter_monomorphic_markers_", file.date, sep = "")
    path.folder.mono <- file.path(path.folder, folder.extension)
    dir.create(path.folder.mono)
    message("Folder created: \n", folder.extension)

    input <- discard_monomorphic_markers(data = input, verbose = verbose)
    blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
    whitelist.markers <- input$whitelist.polymorphic.markers
    input <- input$input

    # update blacklist.markers
    if (nrow(blacklist.monomorphic.markers) > 0) {
      readr::write_tsv(x = blacklist.monomorphic.markers,
                       path = file.path(path.folder.mono, "blacklist.monomorphic.markers.tsv"))
      if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

      if (is.null(blacklist.markers)) {
        blacklist.markers<- blacklist.monomorphic.markers
      } else {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
      }

      new.data.info <- data_info(input)
      if (count.data) {
        new.data.info$n.chrom <- data.info$n.chrom
        new.data.info$n.locus <- NA_integer_
        n.locus.after <- "NA"
        bl.locus <- "NA"
      } else {
        n.locus.after <- new.data.info$n.locus
        bl.locus <- data.info$n.locus - n.locus.after
      }

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "removing monomorphic markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, n.locus.after, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, bl.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.mono, "tidy.data.monomorphic.rad"))
      message("File written: tidy.data.monomorphic.rad")
    }
    blacklist.monomorphic.markers <- NULL
  }# End monomorphic.out

  #7.Filter common markers between all populations  -----------------------------
  if (common.markers) {
    if (verbose) cat("\n### 07: Filtering common markers ######################################\n")
    folder.extension <- stringi::stri_join("07_filter_common_markers_", file.date, sep = "")
    path.folder.common <- file.path(path.folder, folder.extension)
    dir.create(path.folder.common)
    message("Folder created: \n", folder.extension)

    input <- keep_common_markers(data = input, plot = FALSE,
                                 verbose = verbose)
    blacklist.not.in.common.markers <- input$blacklist.not.in.common.markers
    whitelist.markers <- tibble::as_data_frame(input$whitelist.common.markers) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.common, "whitelist.common.markers.tsv"))

    if (file.exists(file.path(getwd(), "whitelist.common.markers.tsv"))) {
      file.remove(file.path(getwd(), "whitelist.common.markers.tsv"))
    }
    input <- input$input

    if (nrow(blacklist.not.in.common.markers) > 0) {
      readr::write_tsv(x = blacklist.not.in.common.markers,
                       path = file.path(path.folder.common, "blacklist.not.in.common.markers.tsv"))
      if (verbose) message("File written: blacklist.not.in.common.markers.tsv")

      new.data.info <- data_info(input) # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "keeping common markers",
        PARAMETERS = "",
        VALUES = "",
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(
          blacklist.markers,
          blacklist.not.in.common.markers)
      } else {
        blacklist.markers <- blacklist.not.in.common.markers
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.common, "tidy.data.common.markers.rad"))
      message("File written: tidy.data.common.markers.rad")
    }
    blacklist.not.in.common.markers <- NULL
  } #End common.markers

  #8.Filter individuals with too many missing -----------------------------------
  if (!is.null(filter.individuals.missing) || interactive.filter) {
    if (verbose) cat("\n### 08: Filtering individuals poorly genotyped ########################\n")
    message("Finding individuals with too many missing genotypes...")
    folder.extension <- stringi::stri_join("08_filter_individuals_missing_", file.date, sep = "")
    path.folder.id.missing <- file.path(path.folder, folder.extension)
    dir.create(path.folder.id.missing)
    message("Folder created: \n", folder.extension)

    ind.missing <-  input %>%
      dplyr::select(INDIVIDUALS, POP_ID, GT_BIN) %>%
      dplyr::group_by(INDIVIDUALS, POP_ID) %>%
      dplyr::summarise(
        GENOTYPED_PROP_INDIVIDUALS = length(GT_BIN[!is.na(GT_BIN)]) / length(GT_BIN)
      ) %>%
      dplyr::ungroup(.) %>%
      dplyr::arrange(GENOTYPED_PROP_INDIVIDUALS) %>%
      readr::write_tsv(x = ., path = file.path(path.folder.id.missing, "individuals.genotyping.info.tsv"))
    pop.levels.missing <- c(levels(ind.missing$POP_ID), "OVERALL")

    overall <- ind.missing %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    ind.missing <- suppressWarnings(dplyr::bind_rows(ind.missing, overall) %>%
                                      dplyr::mutate(POP_ID = factor(POP_ID, levels = pop.levels.missing)))
    overall <- pop.levels.missing <- NULL
    message("generating plot...")
    element.text <- ggplot2::element_text(size = 10,
                                          family = "Helvetica", face = "bold")
    outlier.id <- stats::quantile(ind.missing$GENOTYPED_PROP_INDIVIDUALS[ind.missing$POP_ID == "OVERALL"], 0.25, na.rm = TRUE) -
      (1.5 * stats::IQR(ind.missing$GENOTYPED_PROP_INDIVIDUALS[ind.missing$POP_ID == "OVERALL"], na.rm = TRUE))

    missing.ind.plot <- suppressWarnings(
      ggplot2::ggplot(
        ind.missing, ggplot2::aes(x = POP_ID, y = GENOTYPED_PROP_INDIVIDUALS, na.rm = TRUE)) +
        ggplot2::geom_boxplot() +
        ggplot2::labs(x = "Populations",
                      y = "Individuals genotyped (proportion)",
                      title = "Genotyped/missing information",
                      subtitle = stringi::stri_join("Overall outlier lower range: ", outlier.id)) +
        ggplot2::theme(
          legend.position = "none",
          plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
          plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
          axis.title.y = element.text,
          axis.title.x = element.text,
          axis.text.x = element.text))
    outlier.id <- NULL
    # missing.ind.plot
    suppressWarnings(
      ggplot2::ggsave(
        plot = missing.ind.plot,
        filename = file.path(path.folder.id.missing, "plot.missing.ind.pdf"),
        width = data.info$n.pop * 2, height = 10, dpi = 300, units = "cm",
        useDingbats = FALSE, limitsize = FALSE)
    )

    if (interactive.filter) {
      print(missing.ind.plot)
      filter.individuals.missing <- 0
      message("    Inspect plot and tables to help choose threshold to blacklist individuals")
      message("    Enter the ind minimum genotyped proportion threshold")
      message("    Below this threshold, individuals are blacklisted (e.g. 0.5)")
      # filter.individuals.missing <- as.double(readLines(n = 1))
      filter.individuals.missing <- interactive_question(
        x = "Enter value: ", minmax = c(0, 1))
    }
    missing.ind.plot <- NULL
    blacklist.id <- ind.missing %>%
      dplyr::filter(POP_ID != "OVERALL") %>%
      dplyr::filter(GENOTYPED_PROP_INDIVIDUALS < filter.individuals.missing) %>%
      dplyr::select(INDIVIDUALS)
    ind.missing <- NULL
    if (nrow(blacklist.id) > 0) {
      res$blacklist.id <- dplyr::bind_rows(res$blacklist.id, blacklist.id)
      n.ind.blacklisted <- length(blacklist.id$INDIVIDUALS)
      if (verbose) message("\nBlacklisted individuals: ", n.ind.blacklisted, " ind.")
      if (verbose) message("    Filtering with blacklist of individuals")
      readr::write_tsv(x = blacklist.id, path = file.path(path.folder.id.missing, "blacklist.id.missing.tsv"))

      n.id.before <- dplyr::n_distinct(input$INDIVIDUALS)
      input <- dplyr::filter(input, !INDIVIDUALS %in% blacklist.id$INDIVIDUALS)
      n.id.after <- dplyr::n_distinct(input$INDIVIDUALS)
      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "Filter individuals missing (blacklisted ids)",
        PARAMETERS = "filter.individuals.missing",
        VALUES = filter.individuals.missing,
        BEFORE = n.id.before,
        AFTER = n.id.after,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = ., path = filters.parameters.path,
                         append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- n.id.after
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.id.missing, "tidy.data.ind.missing.rad"))
      message("File written: tidy.data.ind.missing.rad")

      # Remove potential monomorphic markers------
      folder.extension <- stringi::stri_join("filter_monomorphic_markers_", file.date, sep = "")
      path.folder.mono <- file.path(path.folder.id.missing, folder.extension)
      dir.create(path.folder.mono)
      message("Folder created: \n", folder.extension)

      input <- discard_monomorphic_markers(data = input, verbose = verbose)
      blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
      whitelist.markers <- input$whitelist.polymorphic.markers
      input <- input$input

      # update blacklist.markers
      if (nrow(blacklist.monomorphic.markers) > 0) {
        readr::write_tsv(x = blacklist.monomorphic.markers,
                         path = file.path(path.folder.mono, "blacklist.monomorphic.markers.tsv"))
        if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

        if (is.null(blacklist.markers)) {
          blacklist.markers<- blacklist.monomorphic.markers
        } else {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
        }

        new.data.info <- data_info(input)
        if (count.data) {
          new.data.info$n.chrom <- data.info$n.chrom
          new.data.info$n.locus <- NA_integer_
          n.locus.after <- "NA"
          bl.locus <- "NA"
        } else {
          n.locus.after <- new.data.info$n.locus
          bl.locus <- data.info$n.locus - n.locus.after
        }

        # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "removing monomorphic markers",
          PARAMETERS = "",
          VALUES = "",
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, n.locus.after, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, bl.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(x = .,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
        # update data.info
        data.info <- new.data.info
        # Write the file
        radiator::write_rad(data = input, path = file.path(path.folder.mono, "tidy.data.monomorphic.rad"))
        message("File written: tidy.data.monomorphic.rad")
      }
      blacklist.monomorphic.markers <- NULL
    } else {
      if (verbose) message("\nBlacklisted individuals: no")
    }
  }#End filter missing per id


  #9.Filtering markers with too many missing ------------------------------------
  if (!is.null(filter.markers.missing) || interactive.filter) {

    if (verbose) cat("\n### 09: Filtering markers poorly genotyped ############################\n")
    if (!is.null(filter.markers.missing)) {
      ind.approach <- as.character(filter.markers.missing[1])
      ind.threshold <- as.numeric(filter.markers.missing[2])
      prob.pop.threshold <- as.integer(filter.markers.missing[3])
    }

    if (interactive.filter) {
      message("2 steps to visualize and filter markers based on the number of genotyped individuals:")
      message("Step 1. Impact of individual threshold on marker discovery")
      message("Step 2. Choose the filtering approach and thresholds")
    }

    # Folder
    folder.extension <- stringi::stri_join("09_filter_markers_missing_", file.date, sep = "")
    path.folder.ind.filter <- file.path(path.folder, folder.extension)
    dir.create(path.folder.ind.filter)
    message("\nFolder created: \n", folder.extension)

    # prepare filter, table and figure
    ind.total <- dplyr::n_distinct(input$INDIVIDUALS) # total number of individuals
    pop.number <- dplyr::n_distinct(input$POP_ID) # number of pop

    # individuals per pop
    ind.pop <- input %>%
      dplyr::distinct(POP_ID, INDIVIDUALS) %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(N_IND = n)

    # input genotyped
    if (tibble::has_name(input, "GT_BIN")) {
      input.genotyped <- dplyr::filter(input, !is.na(GT_BIN))
    } else {
      input.genotyped <- dplyr::filter(input, GT != "000000")
    }

    # overall genotyped individuals
    overall <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/ind.total*100))

    # number of pop. genotyped per marker
    pop.genotyped.marker <- input.genotyped %>%
      dplyr::distinct(MARKERS, POP_ID) %>%
      dplyr::group_by(MARKERS) %>%
      dplyr::tally(.) %>%
      dplyr::rename(POP_GENOTYPED = n)

    # genotyped individuals per pop
    pop <- input.genotyped %>%
      dplyr::select(MARKERS, INDIVIDUALS, POP_ID) %>%
      dplyr::group_by(MARKERS, POP_ID) %>%
      dplyr::tally(.) %>%
      dplyr::rename(GENOTYPED = n) %>%
      dplyr::inner_join(ind.pop, by = "POP_ID") %>%
      dplyr::mutate(PERCENT = ceiling(GENOTYPED/N_IND*100))

    input.genotyped <- NULL # unused object

    # Step 1. Impact of individual threshold on marker discovery
    threshold.helper.overall <- overall %>%
      dplyr::ungroup(.) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER) %>%
      dplyr::mutate(POP_ID = rep("OVERALL", n()))

    threshold.helper.pop <- pop %>%
      dplyr::group_by(POP_ID) %>%
      dplyr::summarise(
        `10` = length(PERCENT[PERCENT >= 10]),
        `20` = length(PERCENT[PERCENT >= 20]),
        `30` = length(PERCENT[PERCENT >= 30]),
        `40` = length(PERCENT[PERCENT >= 40]),
        `50` = length(PERCENT[PERCENT >= 50]),
        `60` = length(PERCENT[PERCENT >= 60]),
        `70` = length(PERCENT[PERCENT >= 70]),
        `80` = length(PERCENT[PERCENT >= 80]),
        `90` = length(PERCENT[PERCENT >= 90]),
        `100` = length(PERCENT[PERCENT == 100])
      ) %>%
      tidyr::gather(data = ., key = IND_THRESHOLD, value = MARKER_NUMBER, -POP_ID)

    mean.pop <- threshold.helper.pop %>%
      dplyr::group_by(IND_THRESHOLD) %>%
      dplyr::summarise(
        MARKER_NUMBER = round(mean(MARKER_NUMBER), 0)
      ) %>%
      dplyr::mutate(POP_ID = rep("MEAN_POP", n()))

    # Make sure POP_ID is factor
    if (!is.factor(input$POP_ID)) {
      input$POP_ID <- factor(input$POP_ID)
    }

    threshold.helper <- suppressWarnings(
      dplyr::bind_rows(threshold.helper.pop, mean.pop, threshold.helper.overall) %>%
        dplyr::mutate(
          IND_THRESHOLD = as.numeric(IND_THRESHOLD),
          POP_ID = factor(POP_ID, levels = c(levels(input$POP_ID), "MEAN_POP", "OVERALL"), ordered = TRUE)
        ))

    # Set the breaks for the figure
    max.markers <- dplyr::n_distinct(input$MARKERS)

    #Function to replace plyr::round_any
    rounder <- function(x, accuracy, f = round) {
      f(x / accuracy) * accuracy
    }

    # max.markers <- 658
    if (max.markers >= 1000) {
      y.breaks.by <- rounder(max.markers/10, 100, ceiling)
      y.breaks.max <- rounder(max.markers, 1000, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    } else {
      y.breaks.by <- rounder(max.markers/10, 10, ceiling)
      y.breaks.max <- rounder(max.markers, 100, ceiling)
      y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
    }

    plot.ind.threshold <- ggplot2::ggplot(threshold.helper, ggplot2::aes(x = IND_THRESHOLD, y = MARKER_NUMBER)) +
      ggplot2::geom_line() +
      ggplot2::geom_point(size = 2, shape = 21, fill = "white") +
      ggplot2::scale_x_continuous(name = "Individual threshold (percent)", breaks = seq(10, 100, by = 10)) +
      ggplot2::scale_y_continuous(name = "Number of markers", breaks = y.breaks, limits = c(0, y.breaks.max)) +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica", angle = 90, hjust = 1, vjust = 0.5),
        strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
      ) +
      ggplot2::facet_grid(~POP_ID)
    ggplot2::ggsave(
      plot = plot.ind.threshold,
      filename = file.path(path.folder.ind.filter, "plot.ind.threshold.pdf"),
      width = pop.number*5, height = 10,
      dpi = 600, units = "cm", useDingbats = FALSE,
      limitsize = FALSE)

    if (interactive.filter) {
      message("\nStep 1. Impact of individual threshold on marker discovery")
      print(plot.ind.threshold)
      message("Look at the plot and inspect the change in the number of markers
in relation to the individual percentage thresholds\n")
    }

    # Helper table for individual thresholds
    ind.threshold.helper.table <- threshold.helper %>%
      dplyr::group_by(POP_ID) %>%
      tidyr::spread(data = ., key = IND_THRESHOLD, MARKER_NUMBER) %>%
      readr::write_tsv(
        x = .,
        path = file.path(path.folder.ind.filter, "ind.threshold.helper.table.tsv"))
    ind.threshold.helper.table <- NULL
    #     if (interactive.filter) {
    #       message("\nInspect the table (ind.threshold.helper.table) to help you view
    # the relation between individual thresholds and marker discovery:")
    #       message("First column: POP_ID")
    #       message("Remaining columns: the individual thresholds in percent
    # with the value = the number of markers discovered")
    #       message("The last 2 rows: MEAN_POP is the mean across your populations
    # and OVERALL is if you had 1 large population")
    #     }

    # Step 2. Choose the filtering approach and thresholds
    # 2 approach: filtering with the overall n. ind. ("overall") or by pop ("pop")
    if (interactive.filter) {
      message("Step 2. Choose the filtering approach and thresholds")
      message("The approach to filter a marker: do you want it based on the overall
number of genotyped individuals or
on the number of genotyped individuals per pop ? (overall or pop)")
      # ind.approach <- as.character(readLines(n = 1))
      ind.approach <- interactive_question(
        x = "Enter approach: ", answer.opt = c("overall", "pop"))
    }

    if (interactive.filter) {
      # message("Enter the individual threshold percentage")
      # ind.threshold <- as.numeric(readLines(n = 1))
      ind.threshold <- interactive_question(
        x = "Enter the individual threshold percentage: ", minmax = c(0, 100))
    }
    if (interactive.filter && ind.approach == "pop") {
      # message("Tolerance for deviation: look at the plot produced ealier and if you see some populations dragging down
      #         the number of markers for certain percentage thresholds, you have 3 options:\n
      #         1. remove the population (use pop.select argument to keep the desired populations)
      #         2. remove individuals with too many missing genotypes (use blacklist.id argument)
      #         3. use the next threshold (below) to allow variance and then
      #         manage the missing values with blacklist of individuals and/or
      #         missing data imputations.\n
      #         Enter the number of problematic population that you allow to deviate from the threshold:")
      message("Next, the threshold in the number of problematic population that you allow to deviate")
      # prob.pop.threshold <- as.numeric(readLines(n = 1))
      prob.pop.threshold <- interactive_question(
        x = "Enter the threshold: ", minmax = c(0, 100000000))
    }
    if (verbose) message("Filtering data")
    # some discrepencies need to be highlighted here. If you have entire pop not genotyped for a markers
    # this will compute them when doing the filtering:
    # summarise(GENOTYPED = length(INDIVIDUALS[GT != "000000"]))
    # if we first remove the individuals not genotyped with :
    # filter(GT != "000000")
    # the pop not genotyped are not accounted for. And this is what we want here.
    # filter_populations take care the ungenotyped pop and common.markers make sure that for certain analysis
    # you can have common markers or not.
    # so here we focus on when pop got a marker is it at 50% 60% 70%  ... genotyped?
    if (ind.approach == "overall") {
      threshold.id <- "(percent)"
      prob.pop.threshold <- "NA"
      ind.approach <- "overall individuals (no pop)"
      filter <- overall %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::distinct(MARKERS)
    } else {# approach by pop
      threshold.id <- "(percent)"
      ind.approach <- "individuals by pop"
      # ind.threshold <- 0.6
      # prob.pop.threshold <- 3
      filter <- pop %>%
        dplyr::ungroup(.) %>%
        dplyr::filter(PERCENT >= ind.threshold) %>%
        dplyr::group_by(MARKERS) %>%
        dplyr::tally(.) %>%
        dplyr::inner_join(pop.genotyped.marker, by = "MARKERS") %>%
        dplyr::mutate(PROB_POP = POP_GENOTYPED - n) %>%
        dplyr::filter(PROB_POP <= prob.pop.threshold) %>%
        dplyr::distinct(MARKERS)
    }

    # Apply the filter to the tidy data
    input <- dplyr::left_join(x = filter, input, by = "MARKERS")
    new.data.info <- data_info(input) # updating parameters

    n.snp.before <- data.info$n.snp
    if (verbose) message("    Number of markers before = ", n.snp.before)
    n.snp.blacklist <- n.snp.before - new.data.info$n.snp
    if (verbose) message("    Number of markers removed = ", n.snp.blacklist)
    if (verbose) message("    Number of markers after = ", n.snp.before - n.snp.blacklist)

    filters.parameters <- tibble::data_frame(
      FILTERS = "Filter markers missing",
      PARAMETERS = "ind.approach/ind.threshold/prob.pop.threshold",
      VALUES = stringi::stri_join(ind.approach, ind.threshold, prob.pop.threshold, sep = "/"),
      BEFORE = paste(data.info$n.chrom, data.info$n.locus, n.snp.before, sep = "/"),
      AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
      BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, n.snp.blacklist, sep = "/"),
      UNITS = "CHROM/LOCUS/SNP",
      COMMENTS = ""
    ) %>%
      readr::write_tsv(
        x = .,
        path = filters.parameters.path, append = TRUE,
        col_names = FALSE)
    # update data.info
    data.info <- new.data.info

    new.whitelist.markers <- suppressWarnings(
      dplyr::select(input, dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS"))) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE))

    blacklist.markers.geno <- dplyr::setdiff(whitelist.markers, new.whitelist.markers)
    if (nrow(blacklist.markers.geno) > 0) {
      readr::write_tsv(x = blacklist.markers.geno, path = file.path(path.folder.ind.filter, "blacklist.markers.geno.tsv"))
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.geno)
      } else {
        blacklist.markers <- blacklist.markers.geno
      }
    }

    # Write the file
    radiator::write_rad(data = input, path = file.path(path.folder.ind.filter, "tidy.data.markers.geno.rad"))
    message("File written: tidy.data.markers.geno.rad")

    whitelist.markers <- new.whitelist.markers
    new.whitelist.markers <- blacklist.markers.geno <- ind.total <- NULL
    pop.number <- ind.pop <- input.genotyped <- overall <- pop.genotyped.marker <- NULL
    pop <- threshold.helper.overall <- threshold.helper.pop <- NULL
    mean.pop <- threshold.helper <- max.markers <- filter <- NULL
    plot.ind.threshold <- NULL
  }#End filter.markers.missing

  # change to the new directory for MAF filtering
  old.dir <- getwd()
  setwd(path.folder)

  #10.Filter Minor Allele Frequency  ---------------------------------------------
  if (!is.null(maf.thresholds) || interactive.filter) {
    if (verbose) cat("\n### 10: Filtering markers with mac/maf  ###############################\n")

    if (interactive.filter) {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = c("SNP", 1, "OR", 1, 1),
        monomorphic.out = FALSE,
        parallel.core = parallel.core,
        interactive.filter = TRUE)
    } else {
      maf.info <- radiator::filter_maf(
        data = input,
        maf.thresholds = maf.thresholds,
        monomorphic.out = FALSE,
        parallel.core = parallel.core,
        interactive.filter = FALSE)
    }

    old.folder.maf <- list.files(path = path.folder, pattern = "filter_maf")
    new.folder.maf <- stringi::stri_join("10_", old.folder.maf)
    file.rename(from = old.folder.maf, to = new.folder.maf)
    old.folder.maf <- new.folder.maf <- NULL
    param.delete <- list.files(path = path.folder, pattern = "filters_parameters.tsv", full.names = TRUE)
    suppressWarnings(param.delete <- file.remove(param.delete))
    param.delete <- NULL

    param <- maf.info$filters.parameters

    blacklist.markers.maf <- maf.info$blacklist.markers
    whitelist.markers <- maf.info$whitelist.markers
    input <- maf.info$tidy.filtered.maf
    maf.info <- NULL
    if (nrow(blacklist.markers.maf) > 0) {
      readr::write_tsv(x = param,
                       path = filters.parameters.path, append = TRUE,
                       col_names = FALSE)
      n.snp.before <- data.info$n.snp
      n.snp.blacklist <- nrow(blacklist.markers.maf)
      data.info <- data_info(input)
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.markers.maf)
      } else {
        blacklist.markers <- blacklist.markers.maf
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.ind.filter, "tidy.data.markers.geno.rad"))
      message("File written: tidy.data.markers.geno.rad")

      # Write the file
      new.folder.maf <- list.files(path = path.folder, pattern = "10_filter_maf", full.names = TRUE)
      radiator::write_rad(data = input, path = file.path(new.folder.maf, "tidy.data.maf.rad"))
      message("File written: tidy.data.maf.rad")
      new.folder.maf <- NULL
    }
    blacklist.markers.maf <- param <- NULL
  }# End maf.thresholds

  #11.Filter snp number  ---------------------------------------------------------
  if (!is.null(number.snp.reads) || interactive.filter) {
    setwd(path.folder)
    if (verbose) cat("\n### 11: Filtering SNP number per read/locus ###########################\n")
    folder.extension <- stringi::stri_join("11_filter_snp_number_", file.date, sep = "")
    path.folder.snp.number <- file.path(path.folder, folder.extension)
    dir.create(path.folder.snp.number)
    message("Folder created: \n", folder.extension)

    # import markers meta
    input <- dplyr::left_join(
      input,
      radiator::read_rad(
        data = list.files(
          path = path.folder, pattern = "metadata", full.names = TRUE),
        columns = c("MARKERS", "CHROM", "LOCUS", "POS")
      ),
      by = "MARKERS")

    # get the number of SNP per reads/haplotypes/locus
    number.snp <- dplyr::distinct(input, MARKERS, CHROM, LOCUS, POS) %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::mutate(SNP_N = dplyr::n_distinct(POS))

    number.snp.plot.data <- number.snp %>% dplyr::distinct(LOCUS, SNP_N)

    number.snp.reads.plot <- ggplot2::ggplot(number.snp.plot.data, ggplot2::aes(factor(SNP_N))) +
      ggplot2::geom_bar() +
      ggplot2::labs(x = "Number of SNP per haplotypes (reads)") +
      ggplot2::labs(y = "Distribution (number)") +
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        legend.text = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"),
        strip.text.x = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold"))
    number.snp.plot.data <- NULL
    # save
    ggplot2::ggsave(
      filename = file.path(path.folder.snp.number, "number.snp.locus.plot.pdf"),
      plot = number.snp.reads.plot,
      width = 20, height = 10, dpi = 300, units = "cm",
      useDingbats = FALSE, limitsize = FALSE)

    if (interactive.filter) {
      message("\n2 non-exclusive methods to manage short LD and the number of SNPs/reads/locus:")
      message("    1. Remove outlier markers with too many SNPs/locus")
      message("    2. Keep only 1 SNP/locus")
    }

    if (verbose) message("\nPlot written: number.snp.locus.plot.pdf")
    if (interactive.filter) {
      print(number.snp.reads.plot)
      message("\n1. Remove outlier markers with too many SNPs/locus")
      message("    Based on the plot, choose the threshold")
      message("    in maximum number of SNP/locus allowed")
      message("    (turn off by using a large integer): ")
      # number.snp.reads <- as.integer(readLines(n = 1))
      number.snp.reads <- interactive_question(
        x = "\n    Enter the number of SNP: ", minmax = c(0, 100))
    }

    blacklist.snp.number.markers <- number.snp %>%
      dplyr::filter(SNP_N > number.snp.reads) %>%
      dplyr::distinct(LOCUS)

    if (nrow(blacklist.snp.number.markers) > 0) {
      n.snp.before <- data.info$n.snp
      blacklist.snp.number.markers <- dplyr::left_join(
        blacklist.snp.number.markers, input, by = "LOCUS") %>%
        dplyr::select(MARKERS, CHROM, LOCUS, POS) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.snp.number, "blacklist.snp.number.markers.tsv"))

      input <- dplyr::filter(input,
                             !MARKERS %in% blacklist.snp.number.markers$MARKERS)

      whitelist.markers <- dplyr::select(input, dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS"))) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        readr::write_tsv(
          x = .,
          path = file.path(path.folder.snp.number, "whitelist.snp.number.markers.tsv"))
      new.data.info <- data_info(input) # updating parameters

      if (verbose) message("    Number of markers before = ", n.snp.before)
      if (verbose) message("    Number of markers removed = ", data.info$n.snp - new.data.info$n.snp)
      if (verbose) message("    Number of markers after = ", new.data.info$n.snp)

      filters.parameters <- tibble::data_frame(
        FILTERS = "SNP number per reads/locus",
        PARAMETERS = "",
        VALUES = number.snp.reads,
        BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
        AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
        BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
        UNITS = "CHROM/LOCUS/SNP",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = .,
                         path = filters.parameters.path, append = TRUE,
                         col_names = FALSE)
      # update data.info
      data.info <- new.data.info
      if (!is.null(blacklist.markers)) {
        blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.snp.number.markers)
      } else {
        blacklist.markers <- blacklist.snp.number.markers
      }
      # Write the file
      radiator::write_rad(data = input, path = file.path(path.folder.snp.number, "tidy.data.snp.number.rad"))
      message("File written: tidy.data.snp.number.rad")
    }
    blacklist.snp.number.markers <- number.snp <- number.snp.reads.plot <- NULL


    if (interactive.filter) {
      message("\n2. Keep only 1 SNP/locus to manage short LD")
      # message("   Do you want to run this filter (y/n):")
      # run.snp.ld <- as.character(readLines(n = 1))
      run.snp.ld <- interactive_question(
        x = "    Do you want to run this filter (y/n):", answer.opt = c("y", "n"))
    }

    if (interactive.filter && run.snp.ld == "y") {
      message("4 options:")
      message("    random: for a random selection of 1 SNP on the read")
      message("    first: for the first one on the read")
      message("    last: for the last SNP on the read and")
      message("    middle: for locus > 2 SNPs, keep the middle SNP")
      message("    maf: keeps the SNP with the highest MAF")
      # message("\n   ENTER your choice:")
      # snp.ld <- as.character(readLines(n = 1))
      snp.ld <- interactive_question(
        x = "\n    ENTER your choice: ", answer.opt = c("random", "first", "last", "middle", "maf"))
    } else {
      snp.ld <- NULL
    }

    if (!is.null(snp.ld)) {
      snp.ld <- match.arg(snp.ld, c("first", "random", "last", "middle", "maf"))

      if (snp.ld == "maf") {
        maf.data <- list.files(
          path = path.folder, pattern = "maf.data.tsv",
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE)
      } else {
        maf.data <- NULL
      }

      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist.snp.ld.markers <- input %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      input <- snp_ld(
        data = input,
        snp.ld = snp.ld,
        maf.data = maf.data,
        parallel.core = parallel.core)

      whitelist.snp.ld.markers <- input %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE)

      blacklist.snp.ld.markers <- blacklist.snp.ld.markers %>%
        dplyr::filter(!MARKERS %in% whitelist.snp.ld.markers$MARKERS)

      if (nrow(blacklist.snp.ld.markers) > 0) {
        n.snp.before <- data.info$n.snp
        readr::write_tsv(
          x = blacklist.snp.ld.markers,
          path = file.path(path.folder.snp.number, "blacklist.snp.ld.markers.tsv"))
        whitelist.markers <- whitelist.snp.ld.markers %>%
          readr::write_tsv(
            x = .,
            path = file.path(path.folder.snp.number, "whitelist.snp.ld.markers.tsv"))
        new.data.info <- data_info(input) # updating parameters

        #if (verbose) message("    Number of markers before = ", n.snp.before)
        #if (verbose) message("    Number of markers removed = ", data.info$n.snp - new.data.info$n.snp)
        #if (verbose) message("    Number of markers after = ", new.data.info$n.snp)

        filters.parameters <- tibble::data_frame(
          FILTERS = "Short linkage disequilibrium",
          PARAMETERS = "snp.ld",
          VALUES = snp.ld,
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(x = .,
                           path = filters.parameters.path, append = TRUE,
                           col_names = FALSE)
        # update data.info
        data.info <- new.data.info
        if (!is.null(blacklist.markers)) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.snp.ld.markers)
        } else {
          blacklist.markers <- blacklist.snp.ld.markers
        }
        # Write the file
        radiator::write_rad(data = input, path = file.path(path.folder.snp.number, "tidy.data.snp.ld.rad"))
        message("File written: tidy.data.snp.ld.rad")
      }# snp.ld
    }
    whitelist.snp.ld.markers <- blacklist.snp.ld.markers <- NULL
  }#End number.snp.reads

  # Data quality AFTER filters --------------------------------------------------
  #12.Detect mixed genomes -------------------------------------------------------
  if (interactive.filter || mixed.genomes.analysis) {
    if (verbose) cat("\n### 12: Detect mixed genomes ##########################################\n")
    # if (verbose) message("Mixed genomes analysis ...")
    mixed.genomes.analysis <- radiator::detect_mixed_genomes(
      data = input,
      ind.heterozygosity.threshold = ind.heterozygosity.threshold,
      verbose = FALSE)

    blacklist.ind.het <- mixed.genomes.analysis$blacklist.ind.het

    if (interactive.filter) {
      message("\n\nInspect plots and tables in folder created...")
      # message("    Do you want to exclude individuals based on heterozygosity ? (y/n): ")
      # mixed.gen.analysis <- as.character(readLines(n = 1))

      mixed.gen.analysis <- interactive_question(
        x = "Do you want to exclude individuals based on heterozygosity ? (y/n): ", answer.opt = c("y", "n"))

      if (mixed.gen.analysis == "y") {
        mix.text <- "Enter the min value for ind.heterozygosity.threshold argument (0 turns off): "
        # threshold.min <- as.numeric(readLines(n = 1))
        threshold.min <- interactive_question(x = mix.text, minmax = c(0, 1))


        mix.text <- "Enter the max value for ind.heterozygosity.threshold argument (1 turns off): "
        # threshold.max <- as.numeric(readLines(n = 1))
        threshold.max <- interactive_question(x = mix.text, minmax = c(0, 1))



        blacklist.ind.het  <- dplyr::ungroup(mixed.genomes.analysis$individual.heterozygosity) %>%
          dplyr::filter(HET_PROP > threshold.max | HET_PROP < threshold.min) %>%
          dplyr::distinct(INDIVIDUALS)
        ind.heterozygosity.threshold <- as.numeric(c(threshold.min, threshold.max))
      }
    }


    if (!is.null(nrow(blacklist.ind.het)) && nrow(blacklist.ind.het) > 0) {
      n.ind.blacklisted <- length(blacklist.ind.het$INDIVIDUALS)
      message("Filter individual's heterozygosity: ", n.ind.blacklisted, " individual(s) blacklisted")
      mixed.genome.folder <- list.files(path = path.folder, pattern = "detect_mixed_genomes", full.names = TRUE)

      if (length(mixed.genome.folder) > 1) {
        mixed.genome.folder <- file.info(mixed.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        mixed.genome.folder <- mixed.genome.folder$FILE
      }

      readr::write_tsv(
        x = blacklist.ind.het,
        path = stringi::stri_join(mixed.genome.folder, "/blacklist.ind.het.tsv"),
        col_names = TRUE)

      res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.ind.het)

      input <- dplyr::anti_join(
        input,
        blacklist.ind.het, by = "INDIVIDUALS")

      # updating parameters
      filters.parameters <- tibble::data_frame(
        FILTERS = "detect mixed genomes",
        PARAMETERS = "ind.heterozygosity.threshold (min/max)",
        VALUES = stringi::stri_join(ind.heterozygosity.threshold, collapse = "/"),
        BEFORE = data.info$n.ind,
        AFTER = data.info$n.ind - n.ind.blacklisted,
        BLACKLIST = n.ind.blacklisted,
        UNITS = "individuals",
        COMMENTS = ""
      ) %>%
        readr::write_tsv(x = ., path = filters.parameters.path,
                         append = TRUE, col_names = FALSE)
      # update data.info
      data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

      # Filter monomorphic markers again
      input <- discard_monomorphic_markers(data = input, verbose = verbose)
      blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
      whitelist.markers <- input$whitelist.polymorphic.markers
      input <- input$input

      # update blacklist.markers
      if (nrow(blacklist.monomorphic.markers) > 0) {
        readr::write_tsv(x = blacklist.monomorphic.markers,
                         path = file.path(path.folder, "blacklist.monomorphic.markers.tsv"))
        if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

        if (is.null(blacklist.markers)) {
          blacklist.markers<- blacklist.monomorphic.markers
        } else {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
        }

        new.data.info <- data_info(input)

        # updating parameters
        filters.parameters <- tibble::data_frame(
          FILTERS = "removing monomorphic markers",
          PARAMETERS = "",
          VALUES = "",
          BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
          AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
          BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
          UNITS = "CHROM/LOCUS/SNP",
          COMMENTS = ""
        ) %>%
          readr::write_tsv(
            x = .,
            path = filters.parameters.path, append = TRUE,
            col_names = FALSE)
        # update data.info
        data.info <- new.data.info
      }
      blacklist.monomorphic.markers <- NULL
    }
    mixed.genomes.analysis <- NULL

    old.folder <- list.files(path = path.folder, pattern = "detect_mixed_genomes")
    new.folder <- stringi::stri_join("12_", old.folder)
    file.rename(from = old.folder, to = new.folder)

    mono.file <- list.files(path = path.folder, pattern = "blacklist.monomorphic.markers")
    mono.file.full <- list.files(path = path.folder,
                                 pattern = "blacklist.monomorphic.markers",
                                 full.names = TRUE)
    if (length(mono.file) > 0 && file.exists(mono.file)) {
      new.mono.file <- file.path(new.folder, mono.file)
      file.rename(from = mono.file.full, to = new.mono.file)
    }

    # Write the file
    path.genome.mix <- list.files(path = path.folder, pattern = "12_detect_mixed_genomes", full.names = TRUE)
    radiator::write_rad(data = input, path = file.path(path.genome.mix, "tidy.data.mix.gen.rad"))
    message("File written: tidy.data.mix.gen.rad")
    path.genome.mix <- NULL
    old.folder <- new.folder <- mono.file <- mono.file.full <-  NULL
  }# End mixed genomes

  #13.Detect duplicate genomes ---------------------------------------------------
  genome <- duplicate.genomes.analysis[2]
  duplicate.genomes.analysis <- duplicate.genomes.analysis[1]

  if (interactive.filter || duplicate.genomes.analysis) {
    if (verbose) cat("\n### 13: Detect duplicate genomes ######################################\n")

    # if (verbose) message("Duplicate genomes analysis...")
    duplicate.genomes <- radiator::detect_duplicate_genomes(
      data = input,
      distance.method = "manhattan",
      genome = genome,
      blacklist.duplicates = TRUE,
      parallel.core = parallel.core,
      verbose = FALSE)

    # subsample.markers = NULL # test
    # random.seed = NULL # test

    if (interactive.filter) {
      # message("\n\n    Inspect plots and tables")
      # filtering by distance or pairwise genome similarity ?

      message("    Suspicious about the duplicates analysis?")
      message("    Run the full pairwise genome comparisons")
      message("    This approach integrates markers in common & missing data\n")

      dup.text <- "    Do you want to run the pairwise genome comparison (y/n): "
      # genome <- as.character(readLines(n = 1))
      genome <- interactive_question(x = dup.text, answer.opt = c("y", "n"))


      if (genome == "y") {
        duplicate.genomes <- radiator::detect_duplicate_genomes(
          data = input,
          distance.method = "manhattan",
          genome = TRUE,
          blacklist.duplicates = TRUE,
          parallel.core = parallel.core,
          verbose = FALSE)
      }

      old.folder <- list.files(path = path.folder, pattern = "detect_duplicate_genomes")
      new.folder <- stringi::stri_join("13_", old.folder)
      file.rename(from = old.folder, to = new.folder)
      old.folder <- new.folder <- NULL

      dup.genome.folder <- list.files(
        path = path.folder,
        pattern = "detect_duplicate_genomes", full.names = TRUE)

      if (length(dup.genome.folder) > 1) {
        dup.genome.folder <- file.info(dup.genome.folder) %>%
          tibble::rownames_to_column(df = ., var = "FILE") %>%
          dplyr::filter(mtime == max(mtime))
        dup.genome.folder <- dup.genome.folder$FILE
      }

      # Check for a blacklist
      blacklist.id.similar.path <- list.files(
        path = dup.genome.folder,
        pattern = "blacklist.id.similar",
        full.names = TRUE)
      if (length(blacklist.id.similar.path) > 0) {
        blacklist.id.similar <- suppressMessages(
          readr::read_tsv(
            file = blacklist.id.similar.path,
            col_names = TRUE,
            col_types = readr::cols(.default = readr::col_character())))
        n.ind.blacklisted <- length(blacklist.id.similar$INDIVIDUALS)
        if (n.ind.blacklisted > 0) {
          if (verbose) message("Blacklisted individuals: ", n.ind.blacklisted, " ind.")
          if (verbose) message("    Filtering with blacklist of individuals")
          input <- dplyr::filter(input, !INDIVIDUALS %in% blacklist.id.similar$INDIVIDUALS)
          res$blacklist.id <- res$blacklist.id %>% dplyr::bind_rows(blacklist.id.similar)
          blacklist.id.similar <- NULL

          # updating parameters
          filters.parameters <- tibble::data_frame(
            FILTERS = "detect duplicate genomes",
            PARAMETERS = "",
            VALUES = "",
            BEFORE = data.info$n.ind,
            AFTER = data.info$n.ind - n.ind.blacklisted,
            BLACKLIST = n.ind.blacklisted,
            UNITS = "individuals",
            COMMENTS = ""
          ) %>%
            readr::write_tsv(
              x = ., path = filters.parameters.path,
              append = TRUE, col_names = FALSE)
          # update data.info
          data.info$n.ind <- data.info$n.ind - n.ind.blacklisted

          # After removing individuals => check for monomorphic markers
          message("\nScan and remove monomorphic markers, again...")
          input <- discard_monomorphic_markers(data = input, verbose = verbose)
          blacklist.monomorphic.markers <- input$blacklist.monomorphic.markers
          whitelist.markers <- input$whitelist.polymorphic.markers
          input <- input$input
          if (nrow(blacklist.monomorphic.markers) > 0) {
            readr::write_tsv(
              x = blacklist.monomorphic.markers,
              path = file.path(dup.genome.folder, "blacklist.monomorphic.markers.tsv"))
            if (verbose) message("File written: blacklist.monomorphic.markers.tsv")

            new.data.info <- data_info(input)

            # updating parameters
            filters.parameters <- tibble::data_frame(
              FILTERS = "removing monomorphic markers",
              PARAMETERS = "",
              VALUES = "",
              BEFORE = paste(data.info$n.chrom, data.info$n.locus, data.info$n.snp, sep = "/"),
              AFTER = paste(new.data.info$n.chrom, new.data.info$n.locus, new.data.info$n.snp, sep = "/"),
              BLACKLIST = paste(data.info$n.chrom - new.data.info$n.chrom, data.info$n.locus - new.data.info$n.locus, data.info$n.snp - new.data.info$n.snp, sep = "/"),
              UNITS = "CHROM/LOCUS/SNP",
              COMMENTS = ""
            ) %>%
              readr::write_tsv(
                x = .,
                path = filters.parameters.path, append = TRUE,
                col_names = FALSE)
            # update data.info
            data.info <- new.data.info
            if (!is.null(blacklist.markers)) {
              blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.monomorphic.markers)
            } else {
              blacklist.markers <- blacklist.monomorphic.markers
            }
          }
        }
      }
    }
    # Write the file
    path.dup.genomes <- list.files(path = path.folder, pattern = "13_detect_duplicate_genomes", full.names = TRUE)
    radiator::write_rad(data = input, path = file.path(path.dup.genomes, "tidy.data.dup.gen.rad"))
    message("File written: tidy.data.dup.gen.rad")
    path.dup.genomes <- NULL

    duplicate.genomes <- blacklist.monomorphic.markers <- NULL
  }#End duplicate.genomes.analysis

  #14.Filter HWE -----------------------------------------------------------------
  if (interactive.filter || hw.pop.threshold) {
    if (verbose) cat("\n### 14: Filter markers HWE ############################################\n")
    # message to do HW filtering or not
    hw.q <- "Do you want to filter you markers based on HW principles ?\nYou can still opt out after looking at the figures. (y/n): \n"
    do.hw <- interactive_question(x = hw.q, answer.opt = c("y", "n"))

    if (do.hw == "y") {
      input <- filter_hwe(
        interactive.filter = interactive.filter,
        data = input, strata = NULL,
        hw.pop.threshold = hw.pop.threshold,
        midp.threshold = midp.threshold,
        parallel.core = parallel.core,
        verbose = FALSE
      )
      hw.pop.threshold <- input$hw.pop.threshold
      midp.threshold <- input$midp.threshold
      input <- input$tidy.hw.filtered

      old.folder <- list.files(path = path.folder, pattern = "filter_hwe")
      new.folder <- stringi::stri_join("14_", old.folder)
      file.rename(from = old.folder, to = new.folder)

      #update filter parameter file
      n.snp.before <- data.info$n.snp
      new.data.info <- data_info(input)

      # updating parameters
      filters.parameters <- list.files(path = path.folder, pattern = "filter_hwe", full.names = TRUE)
      filters.parameters <- list.files(path = filters.parameters, pattern = "filters_parameters", full.names = TRUE) %>%
        readr::read_tsv(file = ., col_types = readr::cols(.default = readr::col_character())) %>%
        dplyr::filter(VALUES == stringi::stri_join(hw.pop.threshold,"/",midp.threshold)) %>%
        readr::write_tsv(
          x = .,
          path = filters.parameters.path, append = TRUE,
          col_names = FALSE)
      # update data.info
      data.info <- new.data.info

      bl.name <- stringi::stri_join("blacklist.markers.hwd.", midp.threshold,".mid.p.value.", hw.pop.threshold,".hw.pop.threshold")

      if (length(bl.name) > 0) {
        blacklist.hw <- list.files(
          path = path.folder,
          pattern = bl.name,
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE) %>%
          readr::read_tsv(file = ., col_types = "cccc")

        wt.name <- stringi::stri_join("whitelist.markers.hwe.", midp.threshold,".mid.p.value.", hw.pop.threshold,".hw.pop.threshold")
        whitelist.markers <- list.files(
          path = path.folder,
          pattern = wt.name,
          full.names = TRUE, recursive = TRUE, include.dirs = TRUE) %>%
          readr::read_tsv(file = ., col_types = "cccc")

        if (!is.null(blacklist.markers) && nrow(blacklist.hw) > 0) {
          blacklist.markers <- dplyr::bind_rows(blacklist.markers, blacklist.hw)
        } else {
          blacklist.markers <- blacklist.snp.number.markers
        }
        blacklist.hw <- NULL
      }
      if (verbose) message("    Number of markers before = ", n.snp.before)
      if (verbose) message("    Number of markers removed = ", n.snp.before - new.data.info$n.snp)
      if (verbose) message("    Number of markers after = ", new.data.info$n.snp)
    } else {
      hw.pop.threshold <- input$hw.pop.threshold
      midp.threshold <- input$midp.threshold
      input <- input$tidy.hw.filtered
    }
  }#End HW
  # Missing visualization analysis before filters------------------------------
  # if (missing.analysis) {
  #   if (verbose) message("Missing data analysis: after filters")
  #   missing.visualization <- grur::missing_visualization(data = input, write.plot = TRUE)
  # }

  # Writing to working directory the filtered data frame -----------------------
  if (verbose) cat("\n#######################################################################\n")
  # reintroduce REF/ALT
  if (verbose) message("Working to prepare files...")
  markers.meta <- list.files(path = path.folder, pattern = "metadata", full.names = TRUE)

  if (length(markers.meta) > 1) {
    markers.meta <- file.info(markers.meta) %>%
      tibble::rownames_to_column(df = ., var = "FILE") %>%
      dplyr::filter(mtime == max(mtime))
    markers.meta <- markers.meta$FILE
  }

  input <- dplyr::left_join(
    input,
    radiator:: read_rad(markers.meta, columns = c("MARKERS", "REF", "ALT")),
    by = "MARKERS")
  markers.meta <- NULL

  # check REF/ALT alleles + new GT coding
  input <- radiator::change_alleles(
    data = input,
    biallelic = TRUE,
    parallel.core = parallel.core, verbose = TRUE)$input

  # re-introduce all the metadata

  if (count.data) {
    markers.meta <- list.files(path = path.folder, pattern = "temp_markers_coverage_info", full.names = TRUE)

    if (length(markers.meta) > 1) {
      markers.meta <- file.info(markers.meta) %>%
        tibble::rownames_to_column(df = ., var = "FILE") %>%
        dplyr::filter(mtime == max(mtime))
      markers.meta <- markers.meta$FILE
    }

    input <- dplyr::left_join(
      input,
      radiator:: read_rad(data = markers.meta),
      by = c("MARKERS", "INDIVIDUALS")
    )
    file.remove(markers.meta)
    markers.meta <- NULL
  }

  # Whitelist
  res$whitelist.markers <- dplyr::distinct(input, MARKERS, CHROM, LOCUS, POS) %>%
    readr::write_tsv(x = ., path = "whitelist.markers.tsv", col_names = TRUE)
  if (verbose) message("Writing the whitelist of markers: whitelist.markers.tsv")

  if (nrow(blacklist.markers) > 0) {
    res$blacklist.markers <- dplyr::distinct(blacklist.markers, MARKERS) %>%
      readr::write_tsv(x = ., path = "blacklist.markers.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of markers: blacklist.markers.tsv")
  }

  # writing the blacklist of id
  blacklist.id <- NULL
  if (nrow(res$blacklist.id) > 0) {
    readr::write_tsv(x = res$blacklist.id, path = "blacklist.id.tsv", col_names = TRUE)
    if (verbose) message("Writing the blacklist of ids: blacklist.id.tsv")
  }

  # missing memory
  if (verbose) message("Memorizing missing genotypes")
  memory.filename <- stringi::stri_join(filename, "_filtered_missing_memory.rad")
  dplyr::select(
    input, MARKERS, INDIVIDUALS, GT_BIN) %>%
    dplyr::mutate(GT_BIN = is.na(GT_BIN)) %>%
    dplyr::rename(ERASE = GT_BIN) %>%
    dplyr::arrange(MARKERS, INDIVIDUALS) %>%
    radiator::write_rad(data = ., path = memory.filename)
  if (verbose) message("File written: ", memory.filename)

  # Import back the filter parameter file
  res$filters.parameters <- readr::read_tsv(file = filters.parameters.path, col_types = "cccccccc")

  # tidy data
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS",
            "POP_ID", "CALL_RATE", "REP_AVG",
            "AVG_COUNT_REF", "AVG_COUNT_SNP",
            "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
            "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN")
  tidy.name <- stringi::stri_join(filename, "_filtered.rad")
  input <- suppressWarnings(
    dplyr::select(input, dplyr::one_of(want)) %>%
      dplyr::arrange(MARKERS, POP_ID, INDIVIDUALS) %>%
      write_rad(data = ., path = tidy.name)
  )
  message("Filtered tidy data written: ", tidy.name)

  # Generate new strata --------------------------------------------------------
  res$strata <-input %>%
    dplyr::distinct(INDIVIDUALS, POP_ID) %>%
    dplyr::rename(STRATA = POP_ID) %>%
    readr::write_tsv(x = ., path = "new_filtered_strata.tsv")

  # new strata with dart target id
  strata.df %>%
    dplyr::filter(INDIVIDUALS %in% res$strata$INDIVIDUALS) %>%
    readr::write_tsv(x = ., path = "new_filtered_strata_dart.tsv")

  # genomic_converter & Imputations --------------------------------------------
  if (!is.null(output)) {
    if (verbose) message("\nData transferred to genomic converter")
    res$output <- radiator::genomic_converter(
      data = input,
      output = output,
      snp.ld = NULL,
      imputation.method = imputation.method,
      hierarchical.levels = hierarchical.levels,
      num.tree = num.tree,
      parallel.core = parallel.core,
      filename = tidy.name,
      verbose = verbose,
      write.tidy = FALSE)
    last.data.info <- data_info(res$output$tidy.data)
    input <- NULL
  } else {
    last.data.info <- data_info(input)
    res$tidy.data <- input
    input <- NULL
  }

  if (verbose) {

    cat("\n\n\n############################### RESULTS ###############################\n")
    message("DArT data info (before -> after) filters: ")
    message("Number of populations: ", first.data.info$n.pop, " -> ", last.data.info$n.pop)
    message("Number of individuals: ", first.data.info$n.ind, " -> ", last.data.info$n.ind)
    message("Number of chrom: ", first.data.info$n.chrom, " -> ", last.data.info$n.chrom)
    message("Number of locus: ", first.data.info$n.locus, " -> ", last.data.info$n.locus)
    message("Number of SNPs: ", first.data.info$n.snp, " -> ", last.data.info$n.snp)
    timing <- proc.time() - timing
    message("\nComputation time, overall: ", round(timing[[3]]), " sec")
    cat("############################ completed ################################\n")
  }
  setwd(working.dir) #back to the original working directory
  options(width = opt.change)
  return(res)
}#End filter_dart
