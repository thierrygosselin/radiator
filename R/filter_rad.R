# Import, filter and transform a dart output file to different formats

#' @name filter_rad

#' @title Pipeline to filter RADseq data.

#' @description Designed for RADseq data. The function import VCF file,
#' apply filters and generate imputed datasets.
#' The function uses \code{\link[radiator]{tidy_vcf}} and several \code{filter_}
#' functions of radiator.

#' @inheritParams genomic_converter
#' @inheritParams tidy_genomic_data
#' @inheritParams radiator_common_arguments
#' @inheritParams detect_mixed_genomes
#' @inheritParams filter_hwe
#' @inheritParams read_strata

# @param filter.markers.coverage (optional, string, numerical) Filter the lower and
# upper bound of locus/read coverage. The locus/read coverage combines the markers
# average count for REF and ALT allele (respectively the \code{AvgCountRef} and
# \code{AvgCountSnp} info). These markers statistics are generated by DArT.
# If you have count data, use \code{erase.genotypes} argument below instead.
# Default: \code{filter.markers.coverage = NULL}.
# e.g to keep markers with coverage inbetween 7 and 200,
# use : \code{filter.markers.coverage = c(7, 200)}.

# param erase.genotypes (optional, string, numerical) DArT file with count
# data is required for this argument to work. With count data, genotype,
# REF and ALT coverage information is available and is better suited than
# \code{filter.markers.coverage} to remove/erase data based on coverage info.
# This function argument requires 3 values in the string:
#   \enumerate{
#     \item threshold.low.coverage: threshold for the minimum read coverage. Under this threshold,
#     genotypes are erased. e.g. 7
#     \item threshold.gl: threshold that applies only for heterozygous genotypes.
#     Using the \code{threshold.low.coverage} doesn't guarantees that REF and ALT
#     allele have adequate coverage. This threshold does.
#     A genotype likelihood value is generated based
#     on the departure of equal coverage between REF and ALT allele, number of samples
#     sharing the heterozygous genotype for the locus, missing data for the locus
#     and individual. Below the genotype likelihood threshold value,
#     the heterozygous genotypes are erased. e.g. if an heterozygous genotype for a
#     marker as REF/ALT coverage of 100/3 with only 1 sample sharing this info and
#     this sample has 50% missing data and the marker missingness is averaged, the
#     GL value will be extremely low compared to another heterozygous genotype with
#     50/50 of coverage and 10 samples sharing the same genotype...
#     \item threshold.high.coverage: threshold that allows to erase genotypes with
#     very high coverage
#   }
#     e.g. of values: \code{erase.genotypes = c(7, -0.25, 200)}.
#     However, using the \code{interactive.filter = TRUE} is highly recommended to
#     visualize data before choosing values.
#     Default: \code{erase.genotypes = NULL}.

# @param filter.individuals.missing (optional, double) New argument to blacklist
# individuals with too many missing genotypes. Below the threshold, individuals
# are blacklisted. e.g. 0.80 will blacklist individuals with more than 20% missing
# genotypes.
# Default: \code{filter.individuals.missing = NULL}.


# @param filter.markers.missing (optional, string) Similar to call rate, but
# more adapted to the data. 3 values are required in the string, corresponding
# to the \code{\link[radiator]{filter_individual}} module of radiator.
# First value is the approach to count genotyped individuals per markers, \code{"overall"}
# or by \code{"pop"}. Second value is the percent threshold for the marker, with
# \code{70}, 70 percent of genotyped individuals are required to keep the marker.
# The last threshold is the number of problematic population that are allowed to skip
# the threshold. In doubt, use the interactive mode that take step by step these
# arguments. e.g to keep individuals genotyped at >= 70 percent for the markers,
# without considering the population info and allowing 1 population to be problematic for the
# threshold, use: \code{c("overall", 70, 1)}.
# Default: \code{filter.markers.missing = NULL}.


# @param number.snp.reads (optional, integer) This filter removes outlier markers
# with too many SNP number per locus/read.
# Having a higher than "normal" SNP number is usually the results of
# assembly artifacts or bad assembly parameters.
# This filter is population-agnostic. This is best decide after viewing the figures,
# with the interactive mode.
# If the argument is set to \code{number.snp.reads = 2},
# locus with 3 and more SNPs will be blacklisted.
# Default: \code{number.snp.reads = NULL}.

# @param detect.mixed.genomes (optional, logical) Highlight outliers individual's
# observed heterozygosity for a quick
# diagnostic of mixed samples or poor polymorphism discovery due to DNA quality,
# sequencing effort, etc.
# See this function for more info: \code{\link[radiator]{detect_mixed_genomes}}.
# Default: \code{detect.mixed.genomes = TRUE}.


# @param duplicate.genomes.analysis (optional, string) Detect duplicate individuals.
# The function can compute two methods (distance or genome pairwise similarity)
# to highligh potential duplicate individuals.
# See this function for more info: \code{\link[radiator]{detect_duplicate_genomes}}.
# The string required to run the analysis as 2 values:
# \enumerate{
# \item TRUE/FALSE to run the analysis;
# \item Computes pairwise genome similarity (TRUE/FALSE),
# with FALSE just the distance measure is used.
# The pairwise genome similarity is longer to run, but is better because it
# integrates markers in common/missing data.
# Using \code{interactive.filter = TRUE}, can overide this value,
# you can opt in for the pairwise genome similarity after viewing the figures
# used with distance measure... handy!
# }
# Default: \code{detect_duplicate_genomes = c(TRUE, FALSE)}.


#' @param filename (optional) The filename prefix for the objet in the global environment
#' or the working directory. Default: \code{filename = NULL}. A default name will be used,
#' customized with the output file(s) selected.

#' @param ... (optional) To pass further argument for fine-tuning the function.

#' @note
#' The function requires 2 packages (not installed automatically with radiator):
#' \itemize{
#' \item HardyWeinberg: to filter markers in HWD
#' \item ggtern: to generate ternary graph
#' }

#' @return The function returns an object (list). The content of the object
#' can be listed with \code{names(object)} and use \code{$} to isolate specific
#' object (see examples). Some output format will write the output file in the
#' working directory. The tidy genomic data frame is generated automatically.

#' @export
#' @rdname filter_rad
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom readr read_tsv write_tsv
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom stats IQR

#' @examples
#' \dontrun{
#' require(HardyWeinberg)
#' require(ggtern)
#' shark <- radiator::filter_rad(
#'     data = "data.shark.vcf",
#'     strata = "strata.shark.tsv",
#'     output = "genind",
#'     filename = "shark.filters")
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and
#' Peter Grewe \email{peter.grewe@csiro.au}

filter_rad <- function(
  interactive.filter = TRUE,
  data,
  strata = NULL,
  output = NULL,
  filename = NULL,
  verbose = TRUE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {

  # #testing
  # interactive.filter = TRUE
  # strata = NULL
  # output = "genind"
  # filename = NULL
  # verbose = TRUE
  # parallel.core = parallel::detectCores() - 1
  # subsample.markers.stats <- 1
  # #Filters
  # filter.reproducibility = NULL
  # filter.individuals.missing = NULL
  # filter.individuals.heterozygosity = NULL
  # filter.individuals.coverage.total = NULL
  # filter.common.markers = FALSE
  # filter.mac = NULL
  # filter.coverage = NULL
  # filter.genotyping = NULL
  # filter.snp.position.read = NULL
  # filter.snp.number = NULL
  # filter.short.ld = NULL
  # filter.long.ld = NULL
  # long.ld.missing = NULL
  # ld.method <- "r2"
  # filter.strands <- "blacklist"
  # detect.mixed.genomes = NULL
  # detect.duplicate.genomes = NULL
  # filter.hwe = NULL
  # # Others
  # erase.genotypes = NULL
  # random.seed = NULL
  # path.folder = NULL
  # internal = FALSE

  if (verbose) {
    cat("################################################################################\n")
    cat("############################# radiator::filter_rad #############################\n")
    cat("################################################################################\n")
  }
  # Cleanup---------------------------------------------------------------------
  message("The function arguments names have changed: please read documentation\n")
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")
  if (verbose) message("Execution date/time: ", file.date)
  old.dir <- getwd()
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()# for timing
  res <- list()
  #back to the original directory and options
  on.exit(setwd(old.dir), add = TRUE)
  on.exit(options(width = opt.change), add = TRUE)
  on.exit(timing <- proc.time() - timing, add = TRUE)
  on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
  on.exit(if (verbose) cat("############################# completed filter_rad #############################\n"), add = TRUE)

  # Required package -----------------------------------------------------------
  if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"] ||
      !"HardyWeinberg" %in% utils::installed.packages()[,"Package"] ||
      !"ggtern" %in% utils::installed.packages()[,"Package"]
  ) {
    rlang::abort('For this function to work properly,
please install SeqVarTools, HardyWeinberg and ggtern:
install.packages("BiocManager")
install.packages("HardyWeinberg")
install.packages("ggtern")
BiocManager::install("SeqVarTools")
')
  }

  # Function call and dotslist -------------------------------------------------
  rad.dots <- radiator_dots(
    func.name = as.list(sys.call())[[1]],
    fd = rlang::fn_fmls_names(),
    args.list = as.list(environment()),
    dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
    keepers = c(
      "subsample.markers.stats",
      "filter.reproducibility", "filter.individuals.missing",
      "filter.individuals.heterozygosity", "filter.individuals.coverage.total",
      "filter.common.markers", "filter.monomorphic", "filter.mac",
      "filter.coverage", "filter.genotyping", "filter.snp.position.read",
      "filter.snp.number", "filter.short.ld", "filter.long.ld", "long.ld.missing",
      "ld.method", "detect.mixed.genomes", "ind.heterozygosity.threshold",
      "detect.duplicate.genomes",
      "filter.hwe", "hw.pop.threshold", "midp.threshold",
      "filter.strands", "random.seed", "path.folder", "filename",
      "blacklist.genotype", "erase.genotypes",
      "gt", "gt.bin", "gt.vcf", "gt.vcf.nuc",
      "pop.levels", "pop.labels", "pop.select", "blacklist.id",
      "markers.info", "keep.allele.names", "keep.gds", "ref.calibration",
      "vcf.metadata", "vcf.stats",
      "whitelist.markers",
      "write.tidy",
      "dart.sequence",
      "hierarchical.levels", "imputation.method", "pred.mean.matching", "num.tree",
      "missing.memory", "internal"),
    verbose = TRUE
  )

  filter.common.markers.bk <- filter.common.markers


  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) rlang::abort("data is missing")

  # Folders---------------------------------------------------------------------
  # wf for working folder
  # radiator.folder : the 01_radiator folder to put most things...
  wf <- path.folder <- generate_folder(
    f = path.folder,
    rad.folder = "filter_rad",
    prefix_int = FALSE,
    internal = internal,
    file.date = file.date,
    verbose = verbose)

  radiator.folder <- generate_folder(
    f = path.folder,
    rad.folder = "radiator",
    prefix_int = TRUE,
    internal = FALSE,
    file.date = file.date,
    verbose = verbose)

  # write the dots file
  write_rad(
    data = rad.dots,
    path = radiator.folder,
    filename = stringi::stri_join(
      "radiator_filter_rad_args_", file.date, ".tsv"),
    tsv = TRUE,
    internal = internal,
    verbose = verbose
  )

  # Random seed ----------------------------------------------------------------
  if (is.null(random.seed)) {
    random.seed <- sample(x = 1:1000000, size = 1)
    set.seed(random.seed)
  } else {
    set.seed(random.seed)
  }
  readr::write_lines(x = random.seed, path = file.path(radiator.folder, "random.seed"))
  if (verbose) message("File written: random.seed (", random.seed,")")

  # Filter parameter file: generate --------------------------------------------
  filters.parameters <- radiator_parameters(
    generate = TRUE,
    initiate = FALSE,
    update = FALSE,
    parameter.obj = NULL,
    path.folder = radiator.folder,
    file.date = file.date,
    verbose = verbose)

  # File type detection----------------------------------------------------------
  data.type <- radiator::detect_genomic_format(data)

  # Import file ----------------------------------------------------------------
  if (data.type %in% c(
    "tbl_df", "fst.file", "SeqVarGDSClass", "gds.file", "vcf.file", "dart")) {

    if (data.type %in% c("tbl_df", "fst.file", "SeqVarGDSClass", "gds.file")) {
      gds <- read_rad(data)
      data.type <- radiator::detect_genomic_format(gds)
    } else if (data.type %in% c("vcf.file")) {
      gds <- write_seqarray(
        data = data,
        strata = strata,
        filter.strands = filter.strands,
        random.seed = random.seed,
        filter.monomorphic = FALSE,
        filter.common.markers = FALSE,
        internal = TRUE,
        filters.parameters = filters.parameters,
        path.folder = radiator.folder,
        verbose = TRUE)
      data.type <- "SeqVarGDSClass"
    } else {
      gds <- tidy_dart(
        data = data,
        strata = strata,
        filename = filename,
        verbose = TRUE,
        parallel.core = parallel.core,
        path.folder = radiator.folder,
        filters.parameters = filters.parameters,
        internal = TRUE
      )
      data.type <- "SeqVarGDSClass"
    }
  } else {
    gds <- radiator::tidy_genomic_data(
      data = data,
      strata = strata,
      vcf.metadata = TRUE,
      parallel.core = parallel.core,
      verbose = FALSE,
      vcf.stats = TRUE,
      gt.vcf.nuc = TRUE,
      gt.vcf = TRUE,
      gt = TRUE,
      gt.bin = TRUE,
      keep.gds = FALSE
    )

    # Keep GT_BIN
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS",
              "POP_ID", "GT_BIN", "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
              "GQ", "GL_HOM_REF", "GL_HET", "GL_HOM_ALT")
    gds <- suppressWarnings(dplyr::select(gds, dplyr::one_of(want)))
  }

  source <- extract_source(gds) # to know if dart data or not...

  # Filter reproducibility -----------------------------------------------------
  if ("dart" %in% source) {
    gds <- filter_dart_reproducibility(
      data = gds,
      interactive.filter = interactive.filter,
      filter.reproducibility = filter.reproducibility,
      parallel.core = parallel.core,
      verbose = verbose,
      parameters = filters.parameters,
      path.folder = wf)
  }

  # STATISTICS -----------------------------------------------------------------
  # SUBSAMPLE markers
  if (is.null(subsample.markers.stats)) subsample.markers.stats <- 0.2

  # Markers metadata
  markers.meta <- extract_markers_metadata(gds)

  n.markers <- length(markers.meta$VARIANT_ID)
  if (n.markers < 200000) subsample.markers.stats <- 1

  if (subsample.markers.stats < 1) {
    markers.subsampled <- dplyr::sample_frac(tbl = markers.meta,
                                             size = subsample.markers.stats)
    variant.select <- markers.subsampled$VARIANT_ID
    subsample.filename <- stringi::stri_join("markers.subsampled_", file.date, ".tsv")
    dplyr::select(markers.subsampled, MARKERS) %>%
      dplyr::mutate(RANDOM_SEED = random.seed) %>%
      readr::write_tsv(x = .,
                       path = file.path(radiator.folder, subsample.filename))
    markers.subsampled <- NULL
  } else {
    variant.select <- NULL
  }

  # Genotypes metadata ---------------------------------------------------------
  # check for coverage information...
  genotypes.meta <- extract_genotypes_metadata(gds, index.only = TRUE)
  count.data <- "ALLELE_REF_DEPTH" %in% genotypes.meta
  coverage.info <- "READ_DEPTH" %in% genotypes.meta
  genotypes.meta <- NULL

  # filter.individuals.missing -----------------------------------------------
  gds <- filter_individuals(
    data = gds,
    interactive.filter = interactive.filter,
    filter.individuals.missing = filter.individuals.missing,
    filter.individuals.heterozygosity = filter.individuals.heterozygosity,
    filter.individuals.coverage.total = filter.individuals.coverage.total,
    parallel.core = parallel.core,
    verbose = verbose,
    path.folder = wf,
    subsample = variant.select,
    parameters = filters.parameters,
    dp = count.data)

  # Markers stats ------------------------------------------------------------
  if (verbose) message("\nGenerating markers stats\n")
  temp <- generate_markers_stats(
    gds = gds,
    path.folder = radiator.folder,
    filename = NULL,
    file.date = file.date,
    parallel.core = parallel.core,
    subsample = variant.select,
    force.stats = FALSE)
  temp <- NULL

  # Filter common markers ----------------------------------------------------
  gds <- filter_common_markers(
    data = gds,
    filter.common.markers = filter.common.markers.bk,
    plot = TRUE,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # Filter MAC------------------------------------------------------------------
  gds <- filter_mac(
    data = gds,
    interactive.filter = interactive.filter,
    filter.mac = filter.mac,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # Filter coverage-------------------------------------------------------------
  gds <- filter_coverage(
    data = gds,
    interactive.filter = interactive.filter,
    filter.coverage = filter.coverage,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # Filter genotyping---------------------------------------------------------
  gds <- filter_genotyping(
    data = gds,
    interactive.filter = interactive.filter,
    filter.genotyping = filter.genotyping,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # Filter SNP position on the read---------------------------------------------
  gds <- filter_snp_position_read(
    data = gds,
    interactive.filter = interactive.filter,
    filter.snp.position.read = filter.snp.position.read,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # Filter snp number per locus ------------------------------------------------
  gds <- filter_snp_number(
    data = gds,
    interactive.filter = interactive.filter,
    filter.snp.number = filter.snp.number,
    filename = NULL,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    path.folder = wf)

  # return(gds)

  # Filter Linkage disequilibrium --------------------------------------------
  gds <- filter_ld(
    data = gds,
    interactive.filter = interactive.filter,
    filter.short.ld = filter.short.ld,
    filter.long.ld = filter.long.ld,
    parallel.core = parallel.core,
    filename = NULL,
    verbose = verbose,
    long.ld.missing = long.ld.missing,
    ld.method = ld.method,
    parameters = filters.parameters,
    path.folder = wf)

  # Detect mixed genomes -------------------------------------------------------
  gds <- detect_mixed_genomes(
    data = gds,
    interactive.filter = interactive.filter,
    detect.mixed.genomes = detect.mixed.genomes,
    ind.heterozygosity.threshold = NULL,
    parameters = filters.parameters,
    verbose = verbose,
    path.folder = wf)

  #Detect duplicate genomes ---------------------------------------------------
  gds <- detect_duplicate_genomes(
    data = gds,
    interactive.filter = interactive.filter,
    detect.duplicate.genomes = detect.duplicate.genomes,
    parallel.core = parallel.core,
    verbose = verbose,
    parameters = filters.parameters,
    random.seed = random.seed,
    path.folder = wf
  )

  # Filter HWE -----------------------------------------------------------------
  gds <- filter_hwe(
    data = gds,
    interactive.filter = interactive.filter,
    filter.hwe = filter.hwe,
    strata = NULL,
    hw.pop.threshold = hw.pop.threshold,
    midp.threshold = midp.threshold,
    parallel.core = parallel.core,
    parameters = filters.parameters,
    path.folder = wf,
    verbose = verbose)


  # FINAL PREP -----------------------------------------------------------------
  # filtered data folder
  if (verbose) message("\n\nTransferring data to genomic converter...")
  path.folder <- generate_folder(
    f = wf,
    rad.folder = "filtered",
    internal = FALSE,
    file.date = file.date,
    verbose = verbose)


  # Whitelist
  extract_markers_metadata(gds) %>%
    readr::write_tsv(x = ., path = file.path(path.folder, "whitelist.markers.tsv"))
  if (verbose) message("Writing the whitelist of filtered markers: whitelist.markers.tsv")

  # blacklist
  bl <- update_bl_markers(gds = gds, extract = TRUE)
  if (nrow(bl) > 0) {
    readr::write_tsv(x = bl, path = file.path(path.folder, "blacklist.markers.tsv"))
    if (verbose) message("Writing the blacklist of markers: blacklist.markers.tsv")
  }

  # writing the blacklist of id
  blacklist.id <- update_bl_individuals(gds = gds, extract = TRUE)
  if (nrow(blacklist.id) > 0) {
    readr::write_tsv(x = blacklist.id, path = file.path(path.folder, "blacklist.id.tsv"))
    if (verbose) message("Writing the blacklist of ids: blacklist.id.tsv")
  }

  # missing memory
  # if (verbose) message("Memorizing missing genotypes")
  # memory.filename <- stringi::stri_join(filename, "_filtered_missing_memory.rad")
  # dplyr::select(
  #   input, MARKERS, INDIVIDUALS, GT_BIN) %>%
  #   dplyr::mutate(GT_BIN = is.na(GT_BIN)) %>%
  #   dplyr::rename(ERASE = GT_BIN) %>%
  #   dplyr::arrange(MARKERS, INDIVIDUALS) %>%
  #   radiator::write_rad(data = ., path = memory.filename)
  # if (verbose) message("File written: ", memory.filename)


  # Generate new strata
  strata <- extract_individuals(gds = gds, ind.field.select = c("INDIVIDUALS", "STRATA"))
  readr::write_tsv(x = strata, path = file.path(path.folder, "strata.filtered.tsv"))
  if (verbose) message("Writing the filtered strata: strata.filtered.tsv")

  # genomic_converter-----------------------------------------------------------
  output <- genomic_converter(
    data = gds,
    strata = strata,
    output = output,
    parallel.core = parallel.core,
    filename = filename,
    verbose = FALSE,
    path.folder = path.folder,
    parameters = filters.parameters,
    filter.common.markers = FALSE,
    filter.monomorphic = FALSE,
    internal = TRUE)

  if (verbose) {
    sum <- summary_gds(gds = gds, verbose = TRUE)
  }
  return(gds)
}#End filter_rad
