# SNP number per haplotype
#' @name filter_snp_position_read
#' @title Filter markers/SNP based on their position on the read
#' @description This filter removes markers/SNPs based on their position on the read.
#' The data requires snp, locus and col information (e.g. from a VCF file).
#'
#' The impact of assembly artifacts can be tested in downstream analysis with
#' the whitelist and blacklist generated by this function.
#'
#'
#' \strong{Filter targets}: Markers
#'
#' \strong{Statistics}: The position of the SNPs on the read.
#'


#' @inheritParams read_strata
#' @inheritParams radiator_common_arguments

#' @param filter.snp.position.read (character)
#' Options are: \code{"outliers", "q75", "iqr"}. For a safe and conservative
#' value, use \code{"outliers"}, this will remove SNPs with outlier position on
#' the reads.
#' Default: \code{filter.snp.read.position = NULL}.

#' @param filename (optional) Name of the filtered tidy data frame file
#' written to the working directory (ending with \code{.tsv})
#' Default: \code{filename = NULL}.


#' @rdname filter_snp_position_read
#' @export
#' @importFrom ggplot2 ggplot aes geom_violin geom_boxplot stat_summary labs theme element_blank element_text geom_jitter scale_colour_manual scale_y_reverse theme_light geom_bar facet_grid geom_histogram geom_bar aes_string scale_fill_manual theme_bw stat_smooth geom_boxplot ggsave
#' @importFrom stringi stri_join stri_replace_all_fixed stri_sub stri_detect_fixed
#' @importFrom dplyr select distinct group_by ungroup rename arrange tally filter if_else mutate summarise left_join inner_join right_join anti_join semi_join full_join funs
#' @importFrom readr write_tsv
#' @importFrom tibble data_frame has_name

#' @details
#' \strong{Interactive version}
#'
#' There are 2 steps in the interactive version to visualize and filter
#' the data based on the number of SNP on the read/locus:
#'
#' Step 1. SNP number per read/locus visualization
#'
#' Step 2. Choose the filtering thresholds
#'
#'
#' @return A list in the global environment with 6 objects:
#' \enumerate{
#' \item $snp.number.markers
#' \item $number.snp.reads.plot
#' \item $whitelist.markers
#' \item $tidy.filtered.snp.number
#' \item $blacklist.markers
#' \item $filters.parameters
#' }
#'
#' The object can be isolated in separate object outside the list by
#' following the example below.

#' @examples
#' \dontrun{
#' turtle.outlier.snp.number <- radiator::filter_snp_position_read(
#' data = "turtle.vcf",
#' strata = "turtle.strata.tsv",
#' max.snp.number = 4,
#' filename = "tidy.data.turtle.tsv"
#' )

#'
#' tidy.data <- turtle.outlier.snp.number$tidy.filtered.snp.number
#'
#' #Inside the same list, to isolate the markers blacklisted:
#' blacklist <- turtle.outlier.snp.number$blacklist.markers
#'
#' }

filter_snp_position_read <- function(
  interactive.filter = TRUE,
  data,
  strata = NULL,
  filter.snp.position.read = NULL,
  filename = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE,
  ...
) {

  # interactive.filter <- TRUE
  # data <- gds
  # path.folder <- "testing_snp_position"
  # force.stats <- TRUE
  # parameters <- NULL
  # filename <- NULL
  # filter.snp.position.read <- "outliers"
  # parallel.core <- parallel::detectCores() - 1
  # verbose = TRUE

  if (!is.null(filter.snp.position.read) || interactive.filter) {
    if (interactive.filter) verbose <- TRUE
    if (verbose) {
      cat("################################################################################\n")
      cat("######################### radiator::filter_snp_position_read ###################\n")
      cat("################################################################################\n")
    }
    # Cleanup-------------------------------------------------------------------
    file.date <- format(Sys.time(), "%Y%m%d@%H%M")
    if (verbose) message("Execution date@time: ", file.date)
    old.dir <- getwd()
    opt.change <- getOption("width")
    options(width = 70)
    timing <- proc.time()# for timing
    # res <- list()
    #back to the original directory and options
    on.exit(setwd(old.dir), add = TRUE)
    on.exit(options(width = opt.change), add = TRUE)
    on.exit(timing <- proc.time() - timing, add = TRUE)
    on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
    on.exit(if (verbose) cat("##################### completed filter_snp_position_read #######################\n"), add = TRUE)

    # Function call and dotslist -------------------------------------------------
    rad.dots <- radiator_dots(
      func.name = as.list(sys.call())[[1]],
      fd = rlang::fn_fmls_names(),
      args.list = as.list(environment()),
      dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
      keepers = c("path.folder", "parameters", "internal"),
      verbose = verbose
    )

    # Checking for missing and/or default arguments ------------------------------
    if (missing(data)) rlang::abort("data is missing")

    # Folders---------------------------------------------------------------------
    path.folder <- generate_folder(
      f = path.folder,
      rad.folder = "filter_snp_position_read",
      internal = internal,
      file.date = file.date,
      verbose = verbose)

    # write the dots file
    write_rad(
      data = rad.dots,
      path = path.folder,
      filename = stringi::stri_join("radiator_filter_snp_position_read_args_", file.date, ".tsv"),
      tsv = TRUE,
      internal = internal,
      verbose = verbose
    )

    # Message about steps taken during the process ---------------------------------
    if (interactive.filter) {
      message("2 steps to visualize and filter the data based on the number of SNP on the read/locus:")
      message("Step 1. Visualization")
      message("Step 2. Threshold selection")
    }

    # File type detection----------------------------------------------------------
    data.type <- radiator::detect_genomic_format(data)
    if (!data.type %in% c("tbl_df", "fst.file", "SeqVarGDSClass", "gds.file")) {
      rlang::abort("Input not supported for this function: read function documentation")
    }


    if (data.type %in% c("SeqVarGDSClass", "gds.file")) {
      if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"]) {
        rlang::abort('Please install SeqVarTools for this option:\n
             install.packages("BiocManager")
             BiocManager::install("SeqVarTools")')
      }

      if (data.type == "gds.file") {
        data <- radiator::read_rad(data, verbose = verbose)
        data.type <- "SeqVarGDSClass"
      }
    } else {
      if (is.vector(data)) data <- radiator::tidy_wide(data = data, import.metadata = TRUE)
      data.type <- "tbl_df"
    }

    # Filter parameter file: initiate ------------------------------------------
    filters.parameters <- radiator_parameters(
      generate = TRUE,
      initiate = TRUE,
      update = FALSE,
      parameter.obj = parameters,
      data = data,
      path.folder = path.folder,
      file.date = file.date,
      internal = internal,
      verbose = verbose)

    # Whitelist and blacklist --------------------------------------------------
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "COL")
    if (data.type == "SeqVarGDSClass") {
      wl <- bl <- extract_markers_metadata(gds = data, whitelist = TRUE)
      if (!is.numeric(wl$COL)) wl$COL <- as.numeric(wl$COL)
    } else {
      wl <- bl <- dplyr::select(data, dplyr::one_of(want))
    }

    # Check that required info is present in data: snp and locus----------------
    locus.check <- tibble::has_name(wl, "LOCUS")
    snp.check <- tibble::has_name(wl, "POS")
    col.check <- tibble::has_name(wl, "COL")
    if (!locus.check || !snp.check || !col.check) {
      problem.data <- "This filter requires a dataset with SNP (POS), LOCUS and COL informations"
      message("\n\n", problem.data)
      readr::write_lines(
        x = problem.data,
        path = file.path(path.folder, "README"))
      return(data)
    }


    # Generate snp per locus stats----------------------------------------------
    if (verbose) message("Generating SNP position on read stats")
    stats <- tibble_stats(
      x = wl %>%
        dplyr::distinct(MARKERS,COL) %$% COL,# %>% as.numeric(.)
      group = "snp position on read")

    snp.col.iqr.threshold <- c(stats$Q25, stats$Q75)

    # Generate box plot
    read.length <- max(wl$COL)

    fig <- boxplot_stats(
      data = stats,
      title =  "SNP position on the read",
      subtitle = if (!is.null(read.length)) {
        stringi::stri_join("Read length (max): ", read.length, " bp", "\nOutlier: ", ceiling(stats[[9]]))
      } else {
        stringi::stri_join("\nOutlier: ", ceiling(stats[[9]]))
      },
      x.axis.title = NULL,
      y.axis.title = "SNP position on the read (bp)",
      bp.filename = stringi::stri_join("snp.position.read.boxplot_", file.date, ".pdf"),
      path.folder = path.folder)

    # Helper table -------------------------------------------------------------
    if (verbose) message("Generating helper table...")
    n.markers <- nrow(wl)
    helper.table <- tibble::tibble(
      STATS = c("outliers", "q75", "iqr"),
      WHITELISTED_MARKERS = c(
        nrow(dplyr::filter(wl, COL <= stats[[9]])),
        nrow(dplyr::filter(wl, COL <= stats[[5]])),
        nrow(dplyr::filter(wl, COL >= stats[[3]] & COL <= stats[[5]])))
    ) %>%
      dplyr::mutate(
        BLACKLISTED_MARKERS = n.markers - WHITELISTED_MARKERS,
        STATS = factor(x = STATS, levels = c("outliers", "q75", "iqr"), ordered = FALSE)) %>%
      dplyr::arrange(STATS)

    readr::write_tsv(
      x = helper.table,
      path = file.path(path.folder, "snp.position.read.helper.table.tsv"))

    # figures
    markers.plot <- ggplot2::ggplot(
      data = tidyr::gather(
        data = helper.table,
        key = LIST, value = MARKERS, -STATS),
      ggplot2::aes(x = STATS, y = MARKERS)) +
      # ggplot2::geom_line() +
      ggplot2::geom_point(size = 2, shape = 21, fill = "white") +
      ggplot2::scale_x_discrete(name = "SNP position on the read") +
      ggplot2::scale_y_continuous(name = "Number of markers") +
      ggplot2::theme_bw()+
      ggplot2::theme(
        axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
        axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica")#, angle = 90, hjust = 1, vjust = 0.5)
      ) +
      ggplot2::facet_grid(LIST ~. , scales = "free", space = "free")
    print(markers.plot)

    # save
    ggplot2::ggsave(
      filename = file.path(path.folder, "snp.position.read.helper.plot.pdf"),
      plot = markers.plot,
      width = 20,
      height = 15,
      dpi = 300,
      units = "cm",
      useDingbats = FALSE)
    helper.table <- markers.plot <- NULL
    if (verbose) message("Files written: helper tables and plots")

    # Step 2. Thresholds selection ---------------------------------------------
    if (interactive.filter) {
      if (verbose) message("\nStep 2. Filtering markers based on the SNPs position on the read\n")
      filter.snp.position.read <- radiator_question(
        x = "Choice of stats are: 'outliers', 'q75', 'iqr'", answer.opt = c("outliers", "q75", "iqr"))
    }
    filter.snp.position.read <- match.arg(
      filter.snp.position.read,
      choices = c("outliers", "q75", "iqr"),
      several.ok = FALSE)

    # readr::write_tsv(x = stats, path = "testing.stats.tsv")

    # Filtering ----------------------------------------------------------------
    if (filter.snp.position.read == "outliers") {
      wl %<>% dplyr::filter(COL <= stats[[9]])
    }
    if (filter.snp.position.read == "q75") {
      wl %<>% dplyr::filter(COL <= stats[[5]])
    }
    if (filter.snp.position.read == "iqr") {
      wl %<>% dplyr::filter(COL >= stats[[3]] & COL <= stats[[5]])
    }

    # Whitelist and Blacklist of markers
    readr::write_tsv(
      x = wl,
      path = file.path(path.folder, "whitelist.markers.snp.position.read.tsv"),
      append = FALSE, col_names = TRUE)

    bl %<>% dplyr::filter(!MARKERS %in% wl$MARKERS) %>%
      dplyr::mutate(FILTERS = "filter.snp.position.read")
      # dplyr::setdiff(wl) %>% # crash RStudio...

    if (nrow(bl) > 0) {
      readr::write_tsv(
        x = bl,
        path = file.path(path.folder, "blacklist.markers.snp.position.read.tsv"),
        append = FALSE, col_names = TRUE)
    }

    # saving whitelist and blacklist
    if (verbose) message("File written: whitelist.markers.snp.position.read.tsv")
    if (verbose) message("File written: blacklist.markers.snp.position.read.tsv")

    if (data.type == "SeqVarGDSClass") {
      markers.meta <- extract_markers_metadata(gds = data, whitelist = FALSE) %>%
        dplyr::mutate(
          FILTERS = dplyr::if_else(
            VARIANT_ID %in% bl$VARIANT_ID, "filter.snp.position.read", FILTERS
          )
        )

      update_radiator_gds(
        gds = data,
        node.name = "markers.meta",
        value = markers.meta,
        sync = TRUE
      )

      # update blacklist.markers
      # if (nrow(bl) > 0) {
      #   bl %<>% dplyr::select(MARKERS) %>%
      #     dplyr::mutate(FILTER = "filter.snp.position.read")
      #   bl.gds <- update_bl_markers(gds = data, update = bl)
      # }

    } else {
      # Apply the filter to the tidy data
      data  %<>% dplyr::filter(MARKERS %in% wl$MARKERS)
    }

    # radiator_parameters------------------------------------------------------
    filters.parameters <- radiator_parameters(
      generate = FALSE,
      initiate = FALSE,
      update = TRUE,
      parameter.obj = filters.parameters,
      data = data,
      filter.name = "Filter SNPs position on the read",
      param.name = "filter.snp.position.read",
      values = filter.snp.position.read,
      path.folder = path.folder,
      file.date = file.date,
      internal = internal,
      verbose = verbose)

    # results ------------------------------------------------------------------
    radiator_results_message(
      rad.message = stringi::stri_join("\nFilter SNP position on the read : ",
                                       filter.snp.position.read),
      filters.parameters,
      internal,
      verbose
    )
  }
  return(data)
} #End filter_snp_position_read
