# Import, filter and transform a dart output file to different formats

#' @name tidy_dart

#' @title Tidy \href{http://www.diversityarrays.com}{DArT} output file.

#' @description Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users. The function generate a tidy dataset using
#' \href{http://www.diversityarrays.com}{DArT} file.

#' @param data DArT output file. Note that most popular formats used by DArT are
#' recognised (1- and 2- row format, also called binary, and count data.).
#' If you encounter a problem, sent me your data so that I can update
#' the function. The function can import \code{.csv} or \code{.tsv} files.

#' @param strata A tab delimited file with 3 columns.
#' Columns header is:
#' \code{TARGET_ID}, \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals.
#' You need to make sure that
#' the column \code{TARGET_ID} match the id used by DArT.
#' The column \code{INDIVIDUALS} and \code{STRATA} will be kept in the tidy data.
#' Only individuals in the strata file are kept in the tidy, i.e. that the strata
#' is also used as a whitelist of individuals/strata.

#' @inheritParams tidy_genomic_data

#' @return A tidy dataframe with these columns:
#' \enumerate{
#' \item MARKERS: generated by radiator and correspond to CHROM + LOCUS + POS separated by 2 underscores.
#' \item CHROM: the chromosome, for de novo: CHROM_1.
#' \item LOCUS: the locus.
#' \item POS: the SNP id on the LOCUS.
#' \item REF: the reference allele.
#' \item ALT: the alternate allele.
#' \item INDIVIDUALS: the sample name.
#' \item POP_ID: populations id of the sample.
#' \item GT: the genotype in 6 digit format Ã  la genepop.
#' \item GT_VCF: the genotype in VCF format.
#' \item GT_VCF_NUC: the genotype in VCF format, but keeping the nucleotide information.
#' \item GT_BIN: the genotype in binary format similar to PLINK. The number correspond to the number of alternate allele in the genotype.
#' \item CALL_RATE: call rate output specific of DArT.
#' \item AVG_COUNT_REF: the coverage for the reference allele, output specific of DArT.
#' \item AVG_COUNT_SNP: the coverage for the alternate allele, output specific of DArT.
#' \item REP_AVG: the reproducibility average, output specific of DArT.
#' }

#' @export
#' @rdname tidy_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
# @importFrom data.table as.data.table dcast.data.table
#' @importFrom readr read_tsv write_tsv read_lines read_table
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate
#' @importFrom fst write.fst

#' @examples
#' \dontrun{
#' clownfish.dart.tidy <- radiator::tidy_dart(
#' data = "clownfish.dart.tsv",
#' strata = "clownfish.strata.tsv",
#' verbose = TRUE)
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com} and Peter Grewe \email{peter.grewe@csiro.au}

tidy_dart <- function(
  data,
  strata,
  filename = NULL,
  verbose = FALSE,
  parallel.core = parallel::detectCores() - 1
) {
  opt.change <- getOption("width")
  options(width = 70)
  # for timing
  timing <- proc.time()

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  if (missing(strata)) stop("strata file missing")
  # Date and Time --------------------------------------------------------------
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")
  if (is.null(filename)) {
    filename <- stringi::stri_join("radiator_tidy_dart_", file.date, ".rad")
    meta.filename <- stringi::stri_join("radiator_tidy_dart_metadata_", file.date, ".rad")
  } else {
    meta.filename <- stringi::stri_join(filename, "_metadata", ".rad")
    filename <- stringi::stri_join(filename, ".rad")

  }

  # Check DArT format file -----------------------------------------------------
  data.type <- readChar(con = data, nchars = 16L, useBytes = TRUE)
  dart.with.header <- TRUE %in% (stringi::stri_detect_fixed(str = data.type, pattern = c("*\t", "*,")))
  if (dart.with.header) {
    temp.file <- suppressWarnings(suppressMessages(readr::read_table(file = data, n_max = 20, col_names = "HEADER")))
    skip.number <- which(stringi::stri_detect_fixed(str = temp.file$HEADER,
                                                    pattern = "AlleleID")) - 1
    data.type <- readr::read_lines(file = data, skip = skip.number, n_max = skip.number + 1)[1] %>%
      stringi::stri_sub(str = ., from = 1, to = 16)
  } else {
    skip.number <- 0
  }
  temp.file <- NULL
  dart.clone.id <- stringi::stri_detect_fixed(str = data.type, pattern = "CloneID")
  dart.allele.id <- stringi::stri_detect_fixed(str = data.type, pattern = "AlleleID")

  if (dart.clone.id || dart.allele.id) {
    data.type <- "dart"
  } else {
    stop("Contact author to show your DArT data, problem duting import")
  }
  if (verbose) message("Importing DArT data")

  # Strata file ------------------------------------------------------------------
  strata.df <- readr::read_tsv(
    file = strata, col_names = TRUE,
    col_types = readr::cols(.default = readr::col_character()))

  # need to check for duplicate names... yes happening all the time
  duplicate.id.strata <- length(strata.df$INDIVIDUALS) - dplyr::n_distinct(strata.df$INDIVIDUALS)

  if (duplicate.id.strata > 0) {
    message("Duplicated individuals names found in the strata.\n   number of duplicate names = ", duplicate.id.strata, "\n")
    stop("Fix the strata with unique names and\nverify the DArT file for the same issue, adjust accordingly...")
  }

  # Import data ---------------------------------------------------------------

  if (stringi::stri_detect_fixed(
    str = stringi::stri_sub(str = data, from = -4, to = -1),
    pattern = ".csv")) {
    csv <- TRUE
  }

  if (csv) {
    dart.col.type <- readr::read_csv(
      file = data,
      skip = skip.number, n_max = 1,
      na = "-",
      col_names = FALSE,
      col_types = readr::cols(.default = readr::col_character()))
  } else {
    dart.col.type <- readr::read_tsv(
      file = data,
      skip = skip.number, n_max = 1,
      na = "-",
      col_names = FALSE,
      col_types = readr::cols(.default = readr::col_character()))
  }

  want <- tibble::data_frame(
    INFO = c("ALLELEID", "SNP", "SNPPOSITION", "CALLRATE",
             "AVGCOUNTREF", "AVGCOUNTSNP", "REPAVG"),
    COL_TYPE = c("c", "c", "i", "d", "d", "d", "d")) %>%
    dplyr::bind_rows(
      dplyr::select(strata.df, INFO = TARGET_ID) %>%
        dplyr::mutate(COL_TYPE = rep("c", n())))

  dart.col.type <- dart.col.type %>%
    tidyr::gather(data = .,key = DELETE, value = INFO) %>%
    dplyr::select(-DELETE) %>%
    dplyr::mutate(INFO = stringi::stri_trans_toupper(INFO)) %>%
    dplyr::left_join(want, by = "INFO") %>%
    dplyr::mutate(COL_TYPE = stringi::stri_replace_na(str = COL_TYPE, replacement = "_")) %>%
    dplyr::select(COL_TYPE) %>%
    purrr::flatten_chr(.) %>% stringi::stri_join(collapse = "")

  if (csv) {
    input <- suppressMessages(suppressWarnings(
      readr::read_csv(
        file = data,
        skip = skip.number,
        na = "-",
        col_names = TRUE,
        col_types = dart.col.type)
    ))
  } else {
    input <- suppressMessages(suppressWarnings(
      readr::read_tsv(
        file = data,
        skip = skip.number,
        na = "-",
        col_names = TRUE,
        col_types = dart.col.type)
    ))
  }

  colnames(input) <- stringi::stri_trans_toupper(colnames(input))
  colnames(input) <- stringi::stri_replace_all_fixed(
    str = colnames(input),
    pattern = c("AVGCOUNTREF", "AVGCOUNTSNP", "REPAVG", "ALLELEID", "SNPPOSITION", "CALLRATE"),
    replacement = c("AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG", "LOCUS", "POS", "CALL_RATE"),
    vectorize_all = FALSE)

  input <- dplyr::arrange(input, LOCUS, POS)

  # Check for duplicate rows (sometimes people combine DArT data...)----------
  input.dup <- dplyr::distinct(input, LOCUS, SNP, POS, CALL_RATE, .keep_all = FALSE)

  # make sure no duplicates
  if (nrow(input) != nrow(input.dup)) {
    input.dup <- NULL
    message("Duplicate rows were identified")
    message("    using distinct rows")
    message("    check input data if downstream problems")
    input <- dplyr::distinct(input, LOCUS, SNP, POS, CALL_RATE, .keep_all = TRUE)
  }
  input.dup <- NULL

  # Screen for duplicate names -------------------------------------------------
  remove.list <- c("LOCUS", "SNP", "POS", "CALL_RATE", "AVG_COUNT_REF",
                   "AVG_COUNT_SNP", "REP_AVG")
  individuals.df <- tibble::data_frame(
    INDIVIDUALS = purrr::discard(.x = colnames(input),
                                 .p = colnames(input) %in% remove.list))
  duplicate.individuals <- length(individuals.df$INDIVIDUALS) - dplyr::n_distinct(individuals.df$INDIVIDUALS)
  if (duplicate.individuals > 0) {
    stop(stringi::stri_join("Duplicated individuals names found in the data set.\nNumber of duplicate names = ", duplicate.individuals))
  }
  # removing unused object
  remove.list <- individuals.df <- duplicate.individuals <- NULL

  # Tidying data ---------------------------------------------------------------
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE",
            "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

  input <- suppressWarnings(
    input %>%
      tidyr::separate(col = LOCUS, into = c("LOCUS", "NOT_USEFUL"), sep = "\\|", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = SNP, into = c("NOT_USEFUL", "KEEPER"), sep = ":", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = KEEPER, into = c("REF", "ALT"), sep = ">") %>%
      dplyr::mutate(
        CHROM = rep("CHROM_1", n()),
        MARKERS = stringi::stri_join(CHROM, LOCUS, POS, sep = "__")) %>%
      dplyr::select(dplyr::one_of(want), dplyr::everything()) %>%
      dplyr::mutate_at(.tbl = ., .vars = c("MARKERS", "CHROM", "LOCUS", "POS"), .funs = as.character)
  ) %>%
    dplyr::arrange(CHROM, LOCUS, POS, REF)

  # DArT Type-------------------------------------------------------------------
  # Determine the type of DArT file: 1 or 2-row format (binary)
  binary <- anyNA(input$REF)

  # 1-row format----------------------------------------------------------------
  if (!binary) {
    if (verbose) message("Tidying DArT data...")

    # input <- dplyr::filter(input, !is.na(MARKERS))
    grouping.col <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT",
                      "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")
    input <- input %>%
      tidyr::gather(data = ., key = TARGET_ID, value = GT, -dplyr::one_of(grouping.col))

    # generate the split vector
    split.vec <- split_vec_row(x = input, cpu.rounds = 3, parallel.core = parallel.core)

    dart2gt <- function(x) {
      res <- x %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = as.character(GT),
          GT = stringi::stri_replace_all_fixed(
            str = GT, pattern = c("0", "1", "2"),
            replacement = c("RR", "AA", "RA"),
            vectorize_all = FALSE),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), "000000")
        ) %>%
        dplyr::select(GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }#End dart2gt

    input <- dplyr::bind_cols(
      dplyr::select(input, -GT),
      dplyr::select(input, GT, REF, ALT) %>%
        split(x = ., f = split.vec) %>%
        .radiator_parallel(
          X = ., FUN = dart2gt, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.)
    )
    split.vec <- NULL
  }#End 1 row format DArT file

  # Binary dart 2-row format----------------------------------------------------
  if (binary) {
    if (verbose) message("Tidying DArT 2-row-format")

    # To do: merge these 2 functions and simplify codes
    dart_binary <- function(x) {
      res <- dplyr::select(x, -SPLIT_VEC) %>%
        dplyr::group_by(MARKERS, CHROM, LOCUS, POS, TARGET_ID, REF, ALT) %>%
        dplyr::summarise(GT = stringi::stri_join(GT, collapse = "_")) %>%
        dplyr::ungroup(.) %>%
        dplyr::mutate(
          R = REF,
          A = ALT,
          R = stringi::stri_replace_all_fixed(
            str = R, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          A = stringi::stri_replace_all_fixed(
            str = A, pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"), vectorize_all = FALSE),
          GT = dplyr::if_else(GT == "1_0", "RR",
                              dplyr::if_else(GT == "0_1", "AA",
                                             dplyr::if_else(GT == "1_1", "RA", NA_character_))),
          GT_BIN = dplyr::if_else(GT == "RR", 0, dplyr::if_else(GT == "AA", 2, 1)),
          GT_VCF = dplyr::if_else(GT == "RR", "0/0",
                                  dplyr::if_else(GT == "AA", "1/1", "0/1"), missing = "./."),
          GT_VCF_NUC = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = "/"),
                                      dplyr::if_else(GT_VCF == "1/1", stringi::stri_join(ALT, ALT, sep = "/"),
                                                     stringi::stri_join(REF, ALT, sep = "/")), missing = "./."),
          GT = dplyr::if_else(GT == "RR", stringi::stri_join(R, R, sep = ""),
                              dplyr::if_else(GT == "AA", stringi::stri_join(A, A, sep = ""),
                                             stringi::stri_join(R, A, sep = "")), missing = "000000")
        ) %>%
        dplyr::select(MARKERS, CHROM, LOCUS, POS, TARGET_ID, GT, GT_VCF, GT_VCF_NUC, GT_BIN)
      return(res)
    }#End dart_binary
    dart_count <- function(x) {
      x <- dplyr::select(x, -SPLIT_VEC) %>%
        dplyr::arrange(MARKERS, REF) %>%
        dplyr::mutate(TEMP = rep(1:2, n()/2)) %>%
        dplyr::select(dplyr::one_of(c("TEMP", "MARKERS", "CHROM", "LOCUS", "POS","REF", "ALT")), dplyr::everything())

      x.alt <- dplyr::filter(x, TEMP == 1) %>%
        dplyr::arrange(MARKERS) %>%
        dplyr::select(-TEMP) %>%
        tidyr::gather(data = .,
                      key = TARGET_ID,
                      value = ALLELE_ALT_DEPTH,
                      -dplyr::one_of(c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT"))) %>%
        dplyr::arrange(MARKERS, TARGET_ID)

      x <- dplyr::filter(x, TEMP == 2) %>%
        dplyr::arrange(MARKERS) %>%
        dplyr::select(-dplyr::one_of(c("TEMP", "CHROM", "LOCUS", "POS", "REF", "ALT"))) %>%
        tidyr::gather(data = .,
                      key = TARGET_ID,
                      value = ALLELE_REF_DEPTH,
                      -MARKERS) %>%
        dplyr::arrange(MARKERS, TARGET_ID) %>%
        dplyr::select(ALLELE_REF_DEPTH) %>%
        dplyr::bind_cols(x.alt)

      x.alt <- NULL

      x <- x %>%
        dplyr::mutate(
          A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, NA_character_),
          A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, NA_character_),
          VCF_A1 = dplyr::if_else(is.na(A1), NA_integer_, 0L),
          VCF_A2 = dplyr::if_else(is.na(A2), NA_integer_, 1L)
        ) %>%
        dplyr::arrange(MARKERS, TARGET_ID) %>%
        dplyr::mutate(
          A1 = dplyr::if_else(is.na(A1), A2, A1),
          A2 = dplyr::if_else(is.na(A2), A1, A2),
          GT_VCF_NUC = stringi::stri_join(A1, A2, sep = "/"),
          GT_VCF_NUC = stringi::stri_replace_na(str = GT_VCF_NUC, replacement = "./."),
          GT_1 = stringi::stri_replace_all_fixed(
            str = A1,
            pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"),
            vectorize_all = FALSE),
          GT_2 = stringi::stri_replace_all_fixed(
            str = A2,
            pattern = c("A", "C", "G", "T"),
            replacement = c("001", "002", "003", "004"),
            vectorize_all = FALSE),
          GT = stringi::stri_join(GT_1, GT_2),
          GT = stringi::stri_replace_na(str = GT, replacement = "000000")) %>%
        dplyr::select(-c(A1, A2, GT_1, GT_2)) %>%
        dplyr::mutate(
          VCF_A1 = dplyr::if_else(is.na(VCF_A1), VCF_A2, VCF_A1),
          VCF_A2 = dplyr::if_else(is.na(VCF_A2), VCF_A1, VCF_A2),
          GT_VCF = stringi::stri_join(VCF_A1, VCF_A2, sep = "/"),
          GT_VCF = stringi::stri_replace_na(str = GT_VCF, replacement = "./.")
        ) %>%
        dplyr::select(-c(VCF_A1, VCF_A2)) %>%
        dplyr::mutate(
          GT_BIN = as.numeric(
            stringi::stri_replace_all_fixed(
              str = GT_VCF,
              pattern = c("0/0", "1/1", "0/1", "1/0", "./."),
              replacement = c("0", "2", "1", "1", NA),
              vectorize_all = FALSE)))
      return(x)
    }#End dart_count

    # keep one marker and check if genotypes are count data
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE",
              "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")
    gt.counts <- 0 #required to start the while loop
    while (gt.counts == 0) {
      gt.counts <- suppressWarnings(dplyr::select(
        input, -dplyr::one_of(want)) %>%
          dplyr::sample_n(tbl = ., size = 1) %>%
          purrr::flatten_chr(.) %>%
          as.integer %>%
          unique %>% sum(na.rm = TRUE))
    }
    count.data <- gt.counts > 3
    n.markers <- dplyr::n_distinct(input$MARKERS)
    n.individuals <- length(colnames(input)) - 10
    grouping.col <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT",
                      "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

    if (!count.data) {#Genotypes coded 0, 1, 2
      # necessary to deal with the duplication of lines because of the GT in >= 2 lines
      grouping.column <- dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(grouping.col)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS)

      ref.info <- dplyr::distinct(grouping.column, MARKERS, REF, ALT) %>%
        dplyr::arrange(MARKERS)

      markers.split <- dplyr::distinct(ref.info, MARKERS) %>%
        dplyr::mutate(
          SPLIT_VEC = split_vec_row(
            x = .,
            cpu.rounds = 100,
            parallel.core = parallel.core))

      input <- dplyr::select(
        input,
        -dplyr::one_of(c("CHROM", "LOCUS", "POS", "CALL_RATE", "AVG_COUNT_REF",
                         "AVG_COUNT_SNP", "REP_AVG", "REF", "ALT"))) %>%
        tidyr::gather(INDIVIDUALS, GT, -MARKERS) %>%
        dplyr::mutate(
          GT = as.character(GT),
          ALLELES = rep("GT", n())
        ) %>%
        dplyr::left_join(ref.info, by = "MARKERS") %>%
        dplyr::left_join(markers.split, by = "MARKERS") %>%
        split(x = ., f = .$SPLIT_VEC) %>%
        .radiator_parallel(
          X = ., FUN = dart_binary, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.) %>%
        dplyr::left_join(grouping.column, by = "MARKERS") %>%
        dplyr::select(
          dplyr::one_of(
          "MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS", "GT",
          "GT_VCF", "GT_VCF_NUC", "GT_BIN", "CALL_RATE", "AVG_COUNT_REF",
          "AVG_COUNT_SNP", "REP_AVG"))

      grouping.column <- ref.info <- markers.split <- NULL # remove unused object

    } else {
      if (verbose) message("DArT genotype field is count information")
      grouping.column <- dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(grouping.col)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS) %>%
        dplyr::select(-REF, -ALT)

      input <- input %>%
        dplyr::select(-dplyr::one_of(
          c("CALL_RATE", "AVG_COUNT_REF",
            "AVG_COUNT_SNP", "REP_AVG"))) %>%
        dplyr::arrange(MARKERS, REF)

      fst::write.fst(x = grouping.column, path = meta.filename, compress = 85)
      message("Marker's metadata file written to the directory:\n    ", meta.filename)
      grouping.column <- grouping.col <- NULL

      # markers.split <- dplyr::distinct(input, MARKERS) %>%
      #   dplyr::mutate(SPLIT_VEC = split_vec_row(., 2, parallel.core = parallel.core))
      # markers.split <- NULL

      message("Generating genotypes from count data...")
      input <- input %>%
        dplyr::left_join(
          dplyr::distinct(input, MARKERS) %>%
            dplyr::mutate(SPLIT_VEC = split_vec_row(., 4, parallel.core = parallel.core))
          , by = "MARKERS")

      input <- split(x = input, f = input$SPLIT_VEC) %>%
        .radiator_parallel_mc(X = ., FUN = dart_count, mc.cores = parallel.core) %>%
        dplyr::bind_rows(.)

      # when metadata was included..
      # input <- dplyr::bind_rows(replicate(n.individuals, grouping.column, simplify = FALSE)) %>%
      #   dplyr::arrange(MARKERS) %>%
      #   dplyr::bind_cols(input)

      input <- suppressWarnings(dplyr::select(input,
          dplyr::one_of(
            "MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "TARGET_ID", "GT",
            "GT_VCF", "GT_VCF_NUC", "GT_BIN", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
            "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")))
    }
  }#End binary (2-row format) DArT file


  # Strata file ----------------------------------------------------------------
  input <- dplyr::left_join(input, strata.df, by = "TARGET_ID") %>%
    dplyr::select(-TARGET_ID)
  strata.df <- NULL

  if (tibble::has_name(input, "STRATA")) {
    input <- dplyr::rename(input, POP_ID = STRATA)
  }

  input <- suppressWarnings(dplyr::select(
    input,
    dplyr::one_of(
    "MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS", "POP_ID",
    "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN", "CALL_RATE", "AVG_COUNT_REF",
    "AVG_COUNT_SNP", "REP_AVG"),
    dplyr::everything()))

  fst::write.fst(x = input, path = filename, compress = 85)
  message("Unfiltered tidy DArT data written to folder")

  # Results --------------------------------------------------------------------
  if (verbose) {
    n.pop <- dplyr::n_distinct(input$POP_ID)
    n.ind <- dplyr::n_distinct(input$INDIVIDUALS)
    n.chrom <- dplyr::n_distinct(input$CHROM)
    n.locus <- dplyr::n_distinct(input$LOCUS)
    n.snp <- dplyr::n_distinct(input$MARKERS)
    message("Number of populations: ", n.pop)
    message("Number of individuals: ", n.ind)
    message("Number of chrom: ", n.chrom)
    message("Number of locus: ", n.locus)
    message("Number of SNPs: ", n.snp)
    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
  }
  options(width = opt.change)
  return(input)
}#End tidy_dart
