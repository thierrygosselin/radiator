# Import, filter and transform a dart output file to different formats

#' @name tidy_dart

#' @title Tidy \href{http://www.diversityarrays.com}{DArT} output file.

#' @description Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users. The function generate a tidy dataset using
#' \href{http://www.diversityarrays.com}{DArT} file.

#' @param data DArT output file. Note that most popular formats used by DArT are
#' recognised (1- and 2- row format, also called binary, and count data.).
#' If you encounter a problem, sent me your data so that I can update
#' the function. The function can import \code{.csv} or \code{.tsv} files.

#' @param strata A tab delimited file or object with 3 columns.
#' Columns header is:
#' \code{TARGET_ID}, \code{INDIVIDUALS} and \code{STRATA}.
#' Note: the column \code{STRATA} refers to any grouping of individuals.
#' You need to make sure that
#' the column \code{TARGET_ID} match the id used by DArT.
#' The column \code{INDIVIDUALS} and \code{STRATA} will be kept in the tidy data.
#' Only individuals in the strata file are kept in the tidy, i.e. that the strata
#' is also used as a whitelist of individuals/strata.

#' @param tidy.output Superfluous information in the tidy data generated can be
#' discarded automatically in 2 ways: \code{tidy.output == "light"} will remove
#' \code{CROM, LOCUS, POS, GT_VCF, GT_VCF_NUC, GT} columns and
#' \code{tidy.output == "strip"} will only keep
#' \code{MARKERS, INDIVIDUALS, POP_ID, GT_BIN} columns.
#' Default: \code{tidy.output == "full"}.

#' @param verbose (optional, logical) When verbose = TRUE the function is a
#' little more chatty during execution.
#' Default: \code{verbose = FALSE}.

#' @inheritParams tidy_genomic_data

#' @param ... (optional) To pass further argument for fine-tuning the function.


#' @return A tidy dataframe with several columns depending on DArT file:
#' \enumerate{
#' \item MARKERS: generated by radiator and correspond to CHROM + LOCUS + POS separated by 2 underscores.
#' \item CHROM: the chromosome, for de novo: CHROM_1.
#' \item LOCUS: the locus.
#' \item POS: the SNP id on the LOCUS.
#' \item REF: the reference allele.
#' \item ALT: the alternate allele.
#' \item INDIVIDUALS: the sample name.
#' \item POP_ID: populations id of the sample.
#' \item GT: the genotype in 6 digit format Ã  la genepop.
#' \item GT_VCF: the genotype in VCF format.
#' \item GT_VCF_NUC: the genotype in VCF format, but keeping the nucleotide information.
#' \item GT_BIN: the genotype in binary format similar to PLINK. The number correspond to the number of alternate allele in the genotype.
#' \item CALL_RATE: call rate output specific of DArT.
#' \item AVG_COUNT_REF: the coverage for the reference allele, output specific of DArT.
#' \item AVG_COUNT_SNP: the coverage for the alternate allele, output specific of DArT.
#' \item REP_AVG: the reproducibility average, output specific of DArT.
#' \item READ_DEPTH: the number of reads used for the genotype (count data).
#' \item ALLELE_REF_DEPTH: the number of reads of the reference allele (count data).
#' \item ALLELE_ALT_DEPTH: the number of reads of the alternate allele (count data).
#' }
#'
#'
#' Written in the working directory:
#' \itemize{
#' \item The DArT metadata information
#' \item The tidy DArT data
#' \item The strata file associated with this tidy dataset
#' \item The allele dictionary is a tibble with columns:
#' \code{MARKERS, CHROM, LOCUS, POS, REF, ALT}.
#' }

#' @details
#'
#' \strong{... :dot dot dot arguments}
#'
#' Reserved for advanced users. Additional argument passed to the function:
#' \itemize{
#' \item missing.memory: a \code{.rad} file that contains 3 columns:
#' \code{MARKERS, INDIVIDUALS, ERASE}. The file is produced by several radiator
#' functions. For DArT data, \code{\link[radiator]{filter_dart}} generate the file.
#' Allows to erase genotypes that have bad statistics.
#' }


#' @export
#' @rdname tidy_dart
#' @importFrom dplyr group_by select rename filter mutate summarise distinct n_distinct arrange left_join semi_join anti_join inner_join full_join tally bind_rows
#' @importFrom parallel detectCores
#' @importFrom stringi stri_replace_all_fixed stri_join stri_sub stri_replace_na stri_pad_left
#' @importFrom purrr discard
#' @importFrom data.table as.data.table dcast.data.table melt.data.table
#' @importFrom readr read_tsv write_tsv read_lines read_table
#' @importFrom tibble as_data_frame data_frame
#' @importFrom tidyr spread gather unite separate

#' @examples
#' \dontrun{
#' clownfish.dart.tidy <- radiator::tidy_dart(
#' data = "clownfish.dart.tsv",
#' strata = "clownfish.strata.tsv",
#' verbose = TRUE)
#'
#' # To get a strip, bare minimal version of the DArT tidy data:
#' clownfish.dart.tidy <- radiator::tidy_dart(
#' data = "clownfish.dart.tsv",
#' strata = "clownfish.strata.tsv",
#' tidy.output = "strip")
#' # Only MARKERS, INDIVIDUALS, POP_ID, GT_BIN is generated in the output
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

tidy_dart <- function(
  data,
  strata,
  whitelist.markers = NULL,
  filename = NULL,
  tidy.output = "full",
  verbose = FALSE,
  parallel.core = parallel::detectCores() - 1,
  ...
) {
  opt.change <- getOption("width")
  options(width = 70)
  # for timing
  timing <- proc.time()

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")
  if (missing(strata)) stop("strata file missing")

  # dotslist -------------------------------------------------------------------
  # To use someday
  dotslist <- list(...)
  want <- "missing.memory"
  unknowned_param <- setdiff(names(dotslist), want)

  if (length(unknowned_param) > 0) {
    stop("Unknowned \"...\" parameters ",
         stringi::stri_join(unknowned_param, collapse = " "))
  }

  radiator.dots <- dotslist[names(dotslist) %in% want]
  missing.memory <- radiator.dots[["missing.memory"]]

  # Check that DArT file as good target id written -----------------------------
  target.id <- extract_dart_target_id(data, write = FALSE)
  n.ind.dart <- nrow(target.id)
  if (verbose) message("Number of individuals in DArT file: ", n.ind.dart)
  if (nrow(target.id) != length(unique(target.id$TARGET_ID))) {
    stop("\nnon unique target id are used in the DArT file...
What you want are different target ids at the end of the row that contains AlleleID, AlleleSequence, etc
Edit manually before trying again
If you're still encountering problem, email author for help")
  }

  # Date & Time and filenames --------------------------------------------------
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")

  if (is.null(filename)) {
    filename <- stringi::stri_join("radiator_tidy_dart_", file.date, ".rad")
    meta.filename <- stringi::stri_join("radiator_tidy_dart_metadata_", file.date, ".rad")
    strata.filename <- stringi::stri_join("radiator_tidy_dart_strata_", file.date, ".tsv")
    dic.filename <- stringi::stri_join("radiator_tidy_dart_allele_dictionary_", file.date, ".tsv")
  } else {
    dic.filename <- stringi::stri_join(filename, "_allele_dictionary_", file.date, ".tsv")
    meta.filename <- stringi::stri_join(filename, "_metadata_", file.date,".rad")
    strata.filename <- stringi::stri_join(filename, "_strata_", file.date, ".tsv")
    filename <- stringi::stri_join(filename, "_", file.date, ".rad")
  }

  # Check DArT format file -----------------------------------------------------
  data.type <- readChar(con = data, nchars = 16L, useBytes = TRUE)
  dart.with.header <- TRUE %in% (stringi::stri_detect_fixed(str = data.type, pattern = c("*\t", "*,")))
  if (dart.with.header) {
    temp.file <- suppressWarnings(suppressMessages(readr::read_table(file = data, n_max = 20, col_names = "HEADER")))
    skip.number <- which(stringi::stri_detect_fixed(str = temp.file$HEADER,
                                                    pattern = "AlleleID") |
                           stringi::stri_detect_fixed(str = temp.file$HEADER,
                                                      pattern = "CloneID")) - 1
    data.type <- readr::read_lines(file = data, skip = skip.number, n_max = skip.number + 1)[1] %>%
      stringi::stri_sub(str = ., from = 1, to = 16)
  } else {
    skip.number <- 0
  }
  temp.file <- NULL
  dart.clone.id <- stringi::stri_detect_fixed(str = data.type, pattern = "CloneID")
  dart.allele.id <- stringi::stri_detect_fixed(str = data.type, pattern = "AlleleID")

  if (dart.clone.id || dart.allele.id) {
    data.type <- "dart"
  } else {
    stop("\nContact author to show your DArT data, problems during import")
  }
  if (verbose) message("Importing DArT data")

  # Strata file ------------------------------------------------------------------
  if (verbose) message("\nMaking DArT data population-wise...")
  strata.df <- radiator::read_strata(
    strata = strata,
    pop.levels = NULL, pop.labels = NULL,
    pop.select = NULL, blacklist.id = NULL,
    keep.two = FALSE, verbose = verbose)
  pop.levels <- strata.df$pop.levels
  pop.labels <- strata.df$pop.labels
  pop.select <- strata.df$pop.select
  blacklist.id <- strata.df$blacklist.id
  strata.df <- strata.df$strata
  n.ind.strata <- nrow(strata.df)

  # Check that TARGET_ID in strata match TARGET_ID in the DArT file ------------
  if (n.ind.dart != n.ind.strata) {
    strata.id.check <- strata.df %>%
      dplyr::mutate(IN_DART = stringi::stri_trans_toupper(strata.df$TARGET_ID)
                    %in% stringi::stri_trans_toupper(target.id$TARGET_ID))
    strata.id.pass <- !FALSE %in% (unique(strata.id.check$IN_DART))
    if (!strata.id.pass) {
      problem.filename <- stringi::stri_join("radiator_tidy_dart_strata_problem_", file.date, ".tsv")
      readr::write_tsv(
        x = strata.id.check,
        path = problem.filename)
      stop("\nSome of the samples in the strata are not found in the DArT file.
For more info: ", problem.filename)
    }
    message("\nCaution: you've chosen to tidy a subsample of your DArT file.
DArT statistics generated for all samples might not apply...\n")
    strata.id.check <- NULL
  } else {
    if (!identical(sort(target.id$TARGET_ID), sort(strata.df$TARGET_ID))) {
      stop("\nThe DArT and strata files don't have the same TARGET_IDs")
    }
  }
  target.id <- NULL

  # need to check for duplicate names... yes happening all the time
  duplicate.id.strata <- length(strata.df$INDIVIDUALS) - dplyr::n_distinct(strata.df$INDIVIDUALS)

  if (duplicate.id.strata > 0) {
    message("Duplicated individuals names found in the strata.\n   number of duplicate names = ", duplicate.id.strata, "\n")
    stop("\nFix the strata with unique names and\nverify the DArT file for the same issue, adjust accordingly...")
  }

  # Import data ---------------------------------------------------------------
  if (stringi::stri_detect_fixed(
    str = stringi::stri_sub(str = data, from = -4, to = -1),
    pattern = ".csv")) {
    csv <- TRUE
  } else {
    csv <- FALSE
  }

  if (csv) {
    dart.col.type <- readr::read_csv(
      file = data,
      skip = skip.number, n_max = 1,
      na = "-",
      col_names = FALSE,
      col_types = readr::cols(.default = readr::col_character()))
  } else {
    dart.col.type <- readr::read_tsv(
      file = data,
      skip = skip.number, n_max = 1,
      na = "-",
      col_names = FALSE,
      col_types = readr::cols(.default = readr::col_character()))
  }

  want <- tibble::data_frame(
    INFO = c("ALLELEID", "SNP", "SNPPOSITION", "CALLRATE",
             "AVGCOUNTREF", "AVGCOUNTSNP", "REPAVG", "CLONEID", "AVGREADDEPTH", "REPRODUCIBILITY"),
    COL_TYPE = c("c", "c", "i", "d", "d", "d", "d", "c", "d", "d")) %>%
    dplyr::bind_rows(
      dplyr::select(strata.df, INFO = TARGET_ID) %>%
        dplyr::mutate(
          COL_TYPE = rep("c", n()),
          INFO = stringi::stri_trans_toupper(INFO)))

  dart.col.type <- dart.col.type %>%
    tidyr::gather(data = .,key = DELETE, value = INFO) %>%
    dplyr::select(-DELETE) %>%
    dplyr::mutate(
      INFO = stringi::stri_trans_toupper(INFO),
      INFO = stringi::stri_replace_all_fixed(INFO, pattern = " ", replacement = "", vectorize_all = FALSE)
    ) %>%
    dplyr::left_join(want, by = "INFO") %>%
    dplyr::mutate(COL_TYPE = stringi::stri_replace_na(str = COL_TYPE, replacement = "_")) %>%
    dplyr::select(COL_TYPE) %>%
    purrr::flatten_chr(.) %>% stringi::stri_join(collapse = "")
  want <- NULL

  if (csv) {
    input <- suppressMessages(suppressWarnings(
      readr::read_csv(
        file = data,
        skip = skip.number,
        na = c("-", " ", "", "NA"),
        col_names = TRUE,
        col_types = dart.col.type)
    ))
  } else {
    input <- suppressMessages(suppressWarnings(
      readr::read_tsv(
        file = data,
        skip = skip.number,
        na = c("-", " ", "", "NA"),
        col_names = TRUE,
        col_types = dart.col.type)
    ))
  }
  dart.col.type <- NULL
  colnames(input) <- stringi::stri_trans_toupper(colnames(input))
  colnames(input) = stringi::stri_replace_all_fixed(
    str = colnames(input), pattern = " ", replacement = "", vectorize_all = FALSE)
  colnames(input) <- stringi::stri_replace_all_fixed(
    str = colnames(input),
    pattern = c("AVGCOUNTREF", "AVGCOUNTSNP", "REPAVG", "ALLELEID", "SNPPOSITION", "CALLRATE", "REPRODUCIBILITY", "AVGREADDEPTH"),
    replacement = c("AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG", "LOCUS", "POS", "CALL_RATE", "REP_AVG", "AVG_READ_DEPTH"),
    vectorize_all = FALSE)

  if (!tibble::has_name(input, "LOCUS") && tibble::has_name(input, "CLONEID")) {
    colnames(input) <- stringi::stri_replace_all_fixed(
      str = colnames(input),
      pattern = "CLONEID",
      replacement = "LOCUS",
      vectorize_all = FALSE)
  }

  if (tibble::has_name(input, "LOCUS") && tibble::has_name(input, "CLONEID")) {
    input <- dplyr::select(input, -CLONEID)
  }

  if (!tibble::has_name(input, "LOCUS")) stop("\nProblem tidying DArT dataset: contact author")

  # necessary steps...observed with DArT file using ref genome -----------------
  input <- dplyr::filter(input, !is.na(LOCUS))
  if (tibble::has_name(input, "POS")) {
    input <- dplyr::arrange(input, LOCUS, POS)
  } else {
    input <- dplyr::arrange(input, LOCUS)
  }

  # Check for duplicate rows (sometimes people combine DArT data...)----------
  input.dup <- nrow(dplyr::distinct(input, LOCUS, SNP, POS, CALL_RATE, .keep_all = FALSE))

  # make sure no duplicates
  if (nrow(input) != input.dup) {
    message("Duplicate rows were identified")
    message("    using distinct rows")
    message("    check input data if downstream problems")
    input <- dplyr::distinct(input, LOCUS, SNP, POS, CALL_RATE, .keep_all = TRUE)
  }
  input.dup <- NULL

  # Screen for duplicate names -------------------------------------------------
  remove.list <- c("LOCUS", "SNP", "POS", "CALL_RATE", "AVG_COUNT_REF",
                   "AVG_COUNT_SNP", "REP_AVG")
  individuals.df <- tibble::data_frame(
    INDIVIDUALS = purrr::discard(.x = colnames(input),
                                 .p = colnames(input) %in% remove.list))
  duplicate.individuals <- length(individuals.df$INDIVIDUALS) - dplyr::n_distinct(individuals.df$INDIVIDUALS)
  if (duplicate.individuals > 0) {
    stop(stringi::stri_join("\nDuplicated individuals names found in the data set.\nNumber of duplicate names = ", duplicate.individuals))
  }
  # removing unused object
  remove.list <- individuals.df <- duplicate.individuals <- NULL

  # Tidying data ---------------------------------------------------------------
  want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE",
            "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

  input <- suppressWarnings(
    input %>%
      tidyr::separate(col = LOCUS, into = c("LOCUS", "NOT_USEFUL"), sep = "\\|", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = SNP, into = c("NOT_USEFUL", "KEEPER"), sep = ":", extra = "drop") %>%
      dplyr::select(-NOT_USEFUL) %>%
      tidyr::separate(col = KEEPER, into = c("REF", "ALT"), sep = ">") %>%
      dplyr::mutate(
        CHROM = rep("CHROM_1", n()),
        MARKERS = stringi::stri_join(CHROM, LOCUS, POS, sep = "__")) %>%
      dplyr::select(dplyr::one_of(want), dplyr::everything()) %>%
      dplyr::mutate_at(.tbl = ., .vars = c("MARKERS", "CHROM", "LOCUS", "POS"), .funs = as.character)
  ) %>%
    dplyr::arrange(CHROM, LOCUS, POS, REF)

  # Whitelist ------------------------------------------------------------------
  if (!is.null(whitelist.markers)) {
    if (is.vector(whitelist.markers)) {
      whitelist.markers <- readr::read_tsv(
        file = whitelist.markers,
        col_names = TRUE,
        col_types = readr::cols(.default = readr::col_character()))
    }
    columns.names.whitelist <- colnames(whitelist.markers)
    nrow.before <- nrow(whitelist.markers)
    whitelist.markers <- dplyr::distinct(whitelist.markers)
    nrow.after <- nrow(whitelist.markers)
    duplicate.whitelist.markers <- nrow.before - nrow.after
    if (duplicate.whitelist.markers > 0) {
      message("Whitelist of markers with ", duplicate.whitelist.markers, " duplicated identifiers...")
      message("    Creating unique whitelist")
      message("    Warning: downstream results might be impacted by this, check how you made your VCF file...")
    }
    nrow.before <- duplicate.whitelist.markers <- NULL

    whitelist.markers <- dplyr::mutate_all(
      .tbl = whitelist.markers, .funs = clean_markers_names)

    if (verbose) message("Filtering with whitelist of markers")
    if (verbose) message("    Whitelisted markers: ", nrow.after)
    nrow.after <- NULL
    input <- suppressWarnings(
      dplyr::semi_join(input, whitelist.markers, by = columns.names.whitelist)
    )
  }#End filtering DArT with whitelist of markers

  # DArT Type-------------------------------------------------------------------
  # Determine the type of DArT file: 1 or 2-row format (binary)
  binary <- anyNA(input$REF)

  # 1-row format----------------------------------------------------------------
  if (!binary) {
    if (verbose) message("Tidying DArT mapping SNP 1 Row format...")

    # input <- dplyr::filter(input, !is.na(MARKERS))
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT",
              "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")

    # input.bk <- input
    # input <- input.bk
    input <- data.table::as.data.table(input) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = want,
        variable.name = "TARGET_ID", variable.factor = FALSE,
        value.name = "GT"
      ) %>%
      tibble::as_data_frame(.)

    # markers metadata
    dplyr::ungroup(input) %>%
      dplyr::select(dplyr::one_of(want)) %>%
      dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
      dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
      dplyr::arrange(MARKERS) %>%
      radiator::write_rad(
        data = ., path = meta.filename)

    notwanted <- c("CHROM", "LOCUS", "POS", "CALL_RATE", "AVG_COUNT_REF",
                   "AVG_COUNT_SNP", "REP_AVG")

    input <- input %>%
      dplyr::select(-dplyr::one_of(notwanted)) %>%
      dplyr::arrange(MARKERS) %>%
      dplyr::left_join(
        dplyr::distinct(input, MARKERS) %>%
          dplyr::mutate(SPLIT_VEC = split_vec_row(., 4, parallel.core = parallel.core))
        , by = "MARKERS") %>%
      split(x = ., f = .$SPLIT_VEC)

    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "TARGET_ID",
              "CALL_RATE", "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG",
              "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN",
              "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH")
    input <- suppressWarnings(.radiator_parallel(
      X = input,
      FUN = dart2gt,
      mc.cores = parallel.core,
      dart.format = "1row"
    ) %>%
      dplyr::bind_rows(.) %>%
      dplyr::left_join(radiator::read_rad(meta.filename), by = "MARKERS"))


  }#End 1 row format DArT file

  # Binary dart 2-row format----------------------------------------------------
  if (binary) {
    if (verbose) message("Tidying DArT SNP 2 Rows format")

    # keep one marker and check if genotypes are count data
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "CALL_RATE",
              "AVG_COUNT_REF", "AVG_COUNT_SNP", "REP_AVG")
    count.data <- 0 #required to start the while loop
    while (count.data == 0) {
      count.data <- suppressWarnings(dplyr::select(
        input, -dplyr::one_of(want)) %>%
          dplyr::sample_n(tbl = ., size = 3) %>%
          purrr::flatten_chr(.) %>%
          as.integer %>%
          unique %>% sum(na.rm = TRUE))
    }
    count.data <- count.data > 3
    n.markers <- dplyr::n_distinct(input$MARKERS)
    n.individuals <- length(colnames(input)) - 10

    if (!count.data) {#Genotypes coded 0, 1, 2
      # Markers meta
      dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS) %>%
        radiator::write_rad(
          data = ., path = meta.filename)

      notwanted <- c("CHROM", "LOCUS", "POS", "CALL_RATE", "AVG_COUNT_REF",
                     "AVG_COUNT_SNP", "REP_AVG")
      input <- input %>%
        dplyr::select(-dplyr::one_of(notwanted)) %>%
        dplyr::arrange(MARKERS, REF)

      if (verbose) message("Generating genotypes...")
      input <- input %>%
        dplyr::left_join(
          dplyr::distinct(input, MARKERS) %>%
            dplyr::mutate(SPLIT_VEC = split_vec_row(., 4, parallel.core = parallel.core))
          , by = "MARKERS") %>%
        split(x = ., f = .$SPLIT_VEC)

      input <- suppressWarnings(
        .radiator_parallel_mc(
          X = input,
          FUN = dart2gt,
          mc.preschedule = FALSE,
          mc.cores = parallel.core,
          mc.cleanup = FALSE,
          dart.format = "2rows",
          tidy.output = tidy.output
        ) %>%
          dplyr::bind_rows(.) %>%
          dplyr::left_join(radiator::read_rad(meta.filename), by = "MARKERS"))

    } else {
      if (verbose) message("DArT alleles counts (coverage/read depth) detected")
      # Markers meta
      dplyr::ungroup(input) %>%
        dplyr::select(dplyr::one_of(want)) %>%
        dplyr::filter(!is.na(REF) | !is.na(ALT)) %>%
        dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
        dplyr::arrange(MARKERS) %>%
        dplyr::select(-AVG_COUNT_REF, -AVG_COUNT_SNP) %>%
        radiator::write_rad(
          data = ., path = meta.filename)


      notwanted <- c("CHROM", "LOCUS", "POS", "CALL_RATE", "AVG_COUNT_REF",
                     "AVG_COUNT_SNP", "REP_AVG")
      input <- input %>%
        dplyr::select(-dplyr::one_of(notwanted)) %>%
        dplyr::arrange(MARKERS, REF)

      if (verbose) message("Generating genotypes...")
      input <- input %>%
        dplyr::left_join(
          dplyr::distinct(input, MARKERS) %>%
            dplyr::mutate(SPLIT_VEC = split_vec_row(., 10, parallel.core = parallel.core))
          , by = "MARKERS") %>%
        split(x = ., f = .$SPLIT_VEC)
      input <- suppressWarnings(
        .radiator_parallel_mc(
          X = input,
          FUN = dart2gt,
          mc.preschedule = FALSE,
          mc.cores = parallel.core,
          mc.cleanup = FALSE,
          dart.format = "counts",
          tidy.output = tidy.output
        ) %>%
          dplyr::bind_rows(.) %>%
          dplyr::left_join(radiator::read_rad(meta.filename), by = "MARKERS"))
    }
  }#End binary (2-row format) DArT file


  # Strata file to include populations ----------------------------------------
  # To make sure target ids match
  input <- dplyr::left_join(input, strata.df, by = "TARGET_ID") %>%
    dplyr::select(-TARGET_ID)
  strata.df <- NULL

  if (tibble::has_name(input, "STRATA")) {
    input <- dplyr::rename(input, POP_ID = STRATA)
  }

  # Erase genotypes ------------------------------------------------------------
  if (!is.null(missing.memory)) {
    message("Using missing.memory file to erase genotypes")
    missing <- radiator::read_rad(data = missing.memory) %>%
      dplyr::arrange(MARKERS, INDIVIDUALS)

    input <- dplyr::arrange(input, MARKERS, INDIVIDUALS)

    #check identical markers
    same.markers <- identical(unique(missing$MARKERS), unique(input$MARKERS))
    same.individuals<- identical(unique(missing$INDIVIDUALS), unique(input$INDIVIDUALS))
    if (!same.markers || !same.individuals) {
      message("note: data and missing memory don't share all the same markers and/or individuals")
      input <- dplyr::left_join(input, missing, by = c("MARKERS", "INDIVIDUALS"))
      #%>% dplyr::mutate(ERASE = replace(ERASE, which(is.na(ERASE)), FALSE))
      input$ERASE[is.na(input$ERASE)] <- FALSE # faster
      which.missing <- which(input$ERASE)
      input <- dplyr::select(input, -ERASE)
    } else {
      which.missing <- which(missing$ERASE)
    }

    message("Erasing genotypes and genotypes metadata...")
    if (tibble::has_name(input, "GT_BIN")) input$GT_BIN[which.missing] <- NA
    if (tibble::has_name(input, "GT")) input$GT[which.missing] <- "000000"
    if (tibble::has_name(input, "GT_VCF")) input$GT_VCF[which.missing] <- "./."
    if (tibble::has_name(input, "GT_VCF_NUC")) input$GT_VCF_NUC[which.missing] <- "./."
    if (tibble::has_name(input, "READ_DEPTH")) input$READ_DEPTH[which.missing] <- NA
    if (tibble::has_name(input, "ALLELE_REF_DEPTH")) input$ALLELE_REF_DEPTH[which.missing] <- NA
    if (tibble::has_name(input, "ALLELE_ALT_DEPTH")) input$ALLELE_ALT_DEPTH[which.missing] <- NA
  }

  # Writing tidy data ----------------------------------------------------------
  if (tidy.output == "full") {
    want <- c("MARKERS", "CHROM", "LOCUS", "POS", "REF", "ALT", "INDIVIDUALS",
              "POP_ID", "CALL_RATE", "REP_AVG",
              "AVG_COUNT_REF", "AVG_COUNT_SNP",
              "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
              "GT", "GT_VCF", "GT_VCF_NUC", "GT_BIN")
  }

  if (tidy.output == "light") {
    want <- c("MARKERS", "INDIVIDUALS", "POP_ID","REF", "ALT",
              "CALL_RATE", "REP_AVG",
              "AVG_COUNT_REF", "AVG_COUNT_SNP",
              "READ_DEPTH", "ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH",
              "GT_BIN")
  }

  if (tidy.output == "strip") {
    want <- c("MARKERS", "INDIVIDUALS", "POP_ID", "GT_BIN")
  }

  # write REF/ALT dictionary
  dplyr::distinct(input, MARKERS, CHROM, LOCUS, POS, REF, ALT) %>%
    readr::write_tsv(x = ., path = dic.filename)

  # write tidy
  input <- suppressWarnings(
    dplyr::ungroup(input) %>%
      dplyr::select(dplyr::one_of(want)) %>%
      dplyr::mutate(POP_ID = factor(x = POP_ID, levels = pop.levels)) %>%
      dplyr::arrange(MARKERS, POP_ID, INDIVIDUALS)) %>%
    radiator::write_rad(data = ., path = filename)

  if(is.null(whitelist.markers)) {
    if (verbose) message("\nUnfiltered tidy DArT data written to folder")
  } else {
    if (verbose) message("\nWhitelist filtered tidy DArT data written to folder")
  }

  # clean...
  input$INDIVIDUALS <- radiator::clean_ind_names(input$INDIVIDUALS)
  input$POP_ID <- radiator::clean_pop_names(input$POP_ID)

  # Generate a new strata file -------------------------------------------------
  strata <- dplyr::distinct(input, INDIVIDUALS, POP_ID) %>%
    dplyr::rename(STRATA = POP_ID) %>%
    readr::write_tsv(x = ., path = strata.filename)
  # Results --------------------------------------------------------------------
  if (verbose) {
    n.pop <- dplyr::n_distinct(strata$STRATA)
    n.ind <- dplyr::n_distinct(strata$INDIVIDUALS)
    if (tidy.output == "full") n.chrom <- dplyr::n_distinct(input$CHROM)
    if (tidy.output == "full") n.locus <- dplyr::n_distinct(input$LOCUS)
    n.snp <- dplyr::n_distinct(input$MARKERS)
    if (tidy.output == "full") message("\nNumber of chrom: ", n.chrom)
    if (tidy.output == "full") message("Number of locus: ", n.locus)
    message("Number of SNPs: ", n.snp)
    message("Number of populations: ", n.pop)
    message("Number of individuals: ", n.ind)

    strata.stats <- strata %>%
      dplyr::group_by(STRATA) %>%
      dplyr::tally(.) %>%
      dplyr::mutate(POP_IND = stringi::stri_join(STRATA, n, sep = " = "))

    message("\nNumber of ind/pop:\n", stringi::stri_join(strata.stats$POP_IND, collapse ="\n"))
    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
  }
  options(width = opt.change)
  return(input)
}#End tidy_dart


# Internal nested functions ----------------------------------------------------
#' @title dart2gt
#' @description Transform dart genotypes to radiator genotypes fields
#' @rdname dart2gt
#' @keywords internal
#' @export
dart2gt <- function(x, dart.format, tidy.output = "full") {
  # x <- input
  # 1 row format----------------------------------------------------------------
  if (dart.format == "1row") {
    x <- dplyr::select(x, -SPLIT_VEC)
    if (tidy.output == "full") {
      x <- dplyr::bind_rows(
        dplyr::filter(x, is.na(GT)) %>%
          dplyr::mutate(
            GT = "000000",
            GT_VCF = "./.",
            GT_BIN = NA_integer_,
            GT_VCF_NUC = "./.",
            REF = NULL,
            ALT = NULL
          ),
        dplyr::filter(x, !is.na(GT)) %>%
          dplyr::mutate(
            GT = stringi::stri_replace_all_fixed(
              str = GT, pattern = c("0", "1", "2"),
              replacement = c("RR", "AA", "RA"),
              vectorize_all = FALSE),
            GT_VCF = stringi::stri_replace_all_fixed(
              str = GT, pattern = c("RR", "AA", "RA"),
              replacement = c("0/0", "1/1", "0/1"),
              vectorize_all = FALSE),
            GT_BIN = stringi::stri_replace_all_fixed(
              str = GT, pattern = c("RR", "AA", "RA"),
              replacement = c("0", "2", "1"),
              vectorize_all = FALSE),
            GT_BIN = as.integer(GT_BIN),
            GT_VCF_NUC = dplyr::if_else(GT_BIN == "0", stringi::stri_join(REF, REF, sep = "/"),
                                        dplyr::if_else(GT_BIN == "2", stringi::stri_join(ALT, ALT, sep = "/"),
                                                       stringi::stri_join(REF, ALT, sep = "/")), "./."),
            REF = stringi::stri_replace_all_regex(
              str = REF,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            ALT = stringi::stri_replace_all_regex(
              str = ALT,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            GT = dplyr::if_else(GT == "RR", stringi::stri_join(REF, REF, sep = ""),
                                dplyr::if_else(GT == "AA", stringi::stri_join(ALT, ALT, sep = ""),
                                               stringi::stri_join(REF, ALT, sep = "")), "000000"),
            REF = NULL,
            ALT = NULL
          ))
    } else {
      x <- dplyr::bind_rows(
        dplyr::filter(x, is.na(GT)) %>%
          dplyr::mutate(GT = NA_integer_),
        dplyr::filter(x, !is.na(GT)) %>%
          dplyr::mutate(
            GT = stringi::stri_replace_all_fixed(
              str = GT, pattern = c("0", "1", "2"),
              replacement = c("RR", "AA", "RA"),
              vectorize_all = FALSE),
            GT = stringi::stri_replace_all_fixed(
              str = GT, pattern = c("RR", "AA", "RA"),
              replacement = c("0", "2", "1"),
              vectorize_all = FALSE),
            GT = as.integer(GT),
            REF = NULL,
            ALT = NULL
          )) %>%
        dplyr::rename(GT_BIN = GT)
    }
  }#End 1row

  # Common between 2 rows and counts -------------------------------------------
  if (dart.format %in% c("2rows", "counts")) {
    # x <- input
    x <- dplyr::select(x, -SPLIT_VEC) %>%
      dplyr::arrange(MARKERS, REF) %>%
      dplyr::mutate(TEMP = rep(1:2, n()/2)) %>%
      dplyr::select(dplyr::one_of(c("TEMP", "MARKERS", "REF", "ALT")), dplyr::everything())

    x.alt <- dplyr::filter(x, TEMP == 1) %>%
      dplyr::arrange(MARKERS) %>%
      dplyr::select(-TEMP) %>%
      data.table::as.data.table(.) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = c("MARKERS", "REF", "ALT"),
        variable.name = "TARGET_ID", variable.factor = FALSE,
        value.name = "ALLELE_ALT_DEPTH"
      ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::arrange(MARKERS, TARGET_ID)

    x <- dplyr::filter(x, TEMP == 2) %>%
      dplyr::arrange(MARKERS) %>%
      dplyr::select(-dplyr::one_of(c("TEMP", "REF", "ALT"))) %>%
      data.table::as.data.table(.) %>%
      data.table::melt.data.table(
        data = .,
        id.vars = "MARKERS",
        variable.name = "TARGET_ID", variable.factor = FALSE,
        value.name = "ALLELE_REF_DEPTH"
      ) %>%
      tibble::as_data_frame(.) %>%
      dplyr::arrange(MARKERS, TARGET_ID) %>%
      dplyr::select(ALLELE_REF_DEPTH) %>%
      dplyr::bind_cols(x.alt) %>%
      dplyr::mutate_at(
        .tbl = .,
        .vars = c("ALLELE_REF_DEPTH", "ALLELE_ALT_DEPTH"),
        .funs = as.integer) %>%
      dplyr::select(
        dplyr::one_of(
          c("MARKERS", "REF", "ALT", "TARGET_ID", "ALLELE_REF_DEPTH",
            "ALLELE_ALT_DEPTH")))

    x.alt <- NULL
  }

  # 2 rows format also called binary--------------------------------------------
  if (dart.format == "2rows") {
    x <- dplyr::mutate(x, MISSING = is.na(ALLELE_REF_DEPTH) & is.na(ALLELE_ALT_DEPTH))

    if (tidy.output == "full") {
      x <- dplyr::bind_rows(
        dplyr::filter(x, MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            ALLELE_REF_DEPTH = NULL,
            ALLELE_ALT_DEPTH = NULL,
            REF = NULL,
            ALT = NULL,
            GT_VCF = "./.",
            GT_BIN = NA_integer_,
            GT_VCF_NUC = "./.",
            GT = "000000"
          ),
        dplyr::filter(x, !MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, 0L, 1L),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, 1L, 0L),
            GT_VCF = stringi::stri_join(A1, A2, sep = "/"),
            GT_BIN = A1 + A2,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, ALT),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, REF),
            ALLELE_REF_DEPTH = NULL,
            ALLELE_ALT_DEPTH = NULL,
            REF = NULL,
            ALT = NULL,
            GT_VCF_NUC = stringi::stri_join(A1, A2, sep = "/"),
            A1 = stringi::stri_replace_all_regex(
              str = A1,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            A2 = stringi::stri_replace_all_regex(
              str = A2,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            GT = stringi::stri_join(A1, A2),
            A1 = NULL,
            A2 = NULL
          )
      )
    } else {
      x <- dplyr::bind_rows(
        dplyr::filter(x, MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            REF = NULL,
            ALT = NULL,
            ALLELE_REF_DEPTH = NULL,
            ALLELE_ALT_DEPTH = NULL,
            GT_BIN = NA_integer_
          ),
        dplyr::filter(x, !MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            REF = NULL,
            ALT = NULL,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, 0L, 1L),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, 1L, 0L),
            ALLELE_REF_DEPTH = NULL,
            ALLELE_ALT_DEPTH = NULL,
            GT_BIN = A1 + A2,
            A1 = NULL,
            A2 = NULL
          )
      )
    }
  }#End 2rows

  # Count data------------------------------------------------------------------
  if (dart.format == "counts") {
    x<- dplyr::mutate(x, MISSING = ALLELE_REF_DEPTH == 0 & ALLELE_ALT_DEPTH == 0)
    if (tidy.output == "full") {
      x <- dplyr::bind_rows(
        dplyr::filter(x, MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            REF = NULL,
            ALT = NULL,
            GT_VCF = "./.",
            GT_VCF_NUC = "./.",
            GT_BIN = NA_integer_,
            GT = "000000",
            ALLELE_REF_DEPTH = NA_integer_,
            ALLELE_ALT_DEPTH = NA_integer_,
            READ_DEPTH = NA_integer_
          ),
        dplyr::filter(x, !MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, 0L, 1L),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, 1L, 0L),
            GT_VCF = stringi::stri_join(A1, A2, sep = "/"),
            GT_BIN = A1 + A2,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, ALT),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, REF),
            REF = NULL,
            ALT = NULL,
            GT_VCF_NUC = stringi::stri_join(A1, A2, sep = "/"),
            A1 = stringi::stri_replace_all_regex(
              str = A1,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            A2 = stringi::stri_replace_all_regex(
              str = A2,
              pattern = c("^A$", "^C$", "^G$", "^T$"),
              replacement = c("001", "002", "003", "004"),
              vectorize_all = FALSE),
            GT = stringi::stri_join(A1, A2),
            A1 = NULL,
            A2 = NULL,
            READ_DEPTH = ALLELE_REF_DEPTH + ALLELE_ALT_DEPTH
          )
      )

      # Before (slower)
      # x <- x %>%
      #   dplyr::mutate(
      #     A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, NA_character_),
      #     A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, NA_character_),
      #     VCF_A1 = dplyr::if_else(is.na(A1), NA_integer_, 0L),
      #     VCF_A2 = dplyr::if_else(is.na(A2), NA_integer_, 1L)
      #   ) %>%
      #   dplyr::arrange(MARKERS, TARGET_ID) %>%
      #   dplyr::mutate(
      #     A1 = dplyr::if_else(is.na(A1), A2, A1),
      #     A2 = dplyr::if_else(is.na(A2), A1, A2),
      #     GT_VCF_NUC = stringi::stri_join(A1, A2, sep = "/"),
      #     GT_VCF_NUC = stringi::stri_replace_na(str = GT_VCF_NUC, replacement = "./."),
      #     GT_1 = stringi::stri_replace_all_fixed(
      #       str = A1,
      #       pattern = c("A", "C", "G", "T"),
      #       replacement = c("001", "002", "003", "004"),
      #       vectorize_all = FALSE),
      #     GT_2 = stringi::stri_replace_all_fixed(
      #       str = A2,
      #       pattern = c("A", "C", "G", "T"),
      #       replacement = c("001", "002", "003", "004"),
      #       vectorize_all = FALSE),
      #     GT = stringi::stri_join(GT_1, GT_2),
      #     GT = stringi::stri_replace_na(str = GT, replacement = "000000")) %>%
      #   dplyr::select(-c(A1, A2, GT_1, GT_2)) %>%
      #   dplyr::mutate(
      #     VCF_A1 = dplyr::if_else(is.na(VCF_A1), VCF_A2, VCF_A1),
      #     VCF_A2 = dplyr::if_else(is.na(VCF_A2), VCF_A1, VCF_A2),
      #     GT_VCF = stringi::stri_join(VCF_A1, VCF_A2, sep = "/"),
      #     GT_VCF = stringi::stri_replace_na(str = GT_VCF, replacement = "./.")
      #   ) %>%
      #   dplyr::select(-c(VCF_A1, VCF_A2)) %>%
      #   dplyr::mutate(
      #     GT_BIN = as.numeric(
      #       stringi::stri_replace_all_fixed(
      #         str = GT_VCF,
      #         pattern = c("0/0", "1/1", "0/1", "1/0", "./."),
      #         replacement = c("0", "2", "1", "1", NA),
      #         vectorize_all = FALSE)),
      #     ALLELE_REF_DEPTH = as.integer(ALLELE_REF_DEPTH),
      #     ALLELE_ALT_DEPTH = as.integer(ALLELE_ALT_DEPTH),
      #     ALLELE_REF_DEPTH = dplyr::if_else(GT_VCF == "./.", NA_integer_, ALLELE_REF_DEPTH),
      #     ALLELE_ALT_DEPTH = dplyr::if_else(GT_VCF == "./.", NA_integer_, ALLELE_ALT_DEPTH),
      #     READ_DEPTH = ALLELE_REF_DEPTH + ALLELE_ALT_DEPTH)
    } else {
      #before
      # system.time(test1 <- x %>%
      #   dplyr::mutate(
      #     A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, REF, NA_character_),
      #     A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, ALT, NA_character_),
      #     VCF_A1 = dplyr::if_else(is.na(A1), NA_integer_, 0L),
      #     VCF_A2 = dplyr::if_else(is.na(A2), NA_integer_, 1L)
      #   ) %>%
      #   dplyr::arrange(MARKERS, TARGET_ID) %>%
      #   dplyr::select(-c(A1, A2)) %>%
      #   dplyr::mutate(
      #     VCF_A1 = dplyr::if_else(is.na(VCF_A1), VCF_A2, VCF_A1),
      #     VCF_A2 = dplyr::if_else(is.na(VCF_A2), VCF_A1, VCF_A2),
      #     GT_VCF = stringi::stri_join(VCF_A1, VCF_A2, sep = "/"),
      #     GT_VCF = stringi::stri_replace_na(str = GT_VCF, replacement = "./.")
      #   ) %>%
      #   dplyr::select(-c(VCF_A1, VCF_A2)) %>%
      #   dplyr::mutate(
      #     GT_BIN = as.numeric(
      #       stringi::stri_replace_all_fixed(
      #         str = GT_VCF,
      #         pattern = c("0/0", "1/1", "0/1", "1/0", "./."),
      #         replacement = c("0", "2", "1", "1", NA),
      #         vectorize_all = FALSE)),
      #     ALLELE_REF_DEPTH = as.integer(ALLELE_REF_DEPTH),
      #     ALLELE_ALT_DEPTH = as.integer(ALLELE_ALT_DEPTH),
      #     ALLELE_REF_DEPTH = dplyr::if_else(GT_VCF == "./.", NA_integer_, ALLELE_REF_DEPTH),
      #     ALLELE_ALT_DEPTH = dplyr::if_else(GT_VCF == "./.", NA_integer_, ALLELE_ALT_DEPTH),
      #     READ_DEPTH = ALLELE_REF_DEPTH + ALLELE_ALT_DEPTH))

      # now faster:
      x <- dplyr::bind_rows(
        dplyr::filter(x, MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            REF = NULL,
            ALT = NULL,
            GT_BIN = NA_integer_,
            ALLELE_REF_DEPTH = NA_integer_,
            ALLELE_ALT_DEPTH = NA_integer_,
            READ_DEPTH = NA_integer_
          ),
        dplyr::filter(x, !MISSING) %>%
          dplyr::mutate(
            MISSING = NULL,
            REF = NULL,
            ALT = NULL,
            A1 = dplyr::if_else(ALLELE_REF_DEPTH > 0, 0L, 1L),
            A2 = dplyr::if_else(ALLELE_ALT_DEPTH > 0, 1L, 0L),
            GT_BIN = A1 + A2,
            A1 = NULL,
            A2 = NULL,
            READ_DEPTH = ALLELE_REF_DEPTH + ALLELE_ALT_DEPTH
          )
      )

      # Without th GT_BIN
      # x <- dplyr::bind_rows(
      #   dplyr::filter(x, MISSING) %>%
      #     dplyr::mutate(
      #       MISSING = NULL,
      #       REF = NULL,
      #       ALT = NULL,
      #       ALLELE_REF_DEPTH = NA_integer_,
      #       ALLELE_ALT_DEPTH = NA_integer_,
      #       READ_DEPTH = NA_integer_
      #     ),
      #   dplyr::filter(x, !MISSING) %>%
      #     dplyr::mutate(
      #       MISSING = NULL,
      #       REF = NULL,
      #       ALT = NULL,
      #       READ_DEPTH = ALLELE_REF_DEPTH + ALLELE_ALT_DEPTH
      #     )
      # )
    }
  }#End counts data

  return(x)
}#End dart2gt


