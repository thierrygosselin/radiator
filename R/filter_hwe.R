#' @name filter_hwe
#' @title Filter markers based on Hardy-Weinberg Equilibrium
#' @description Testing markers for Hardy-Weinberg proportions is a valuable tool
#' for the analysis and quality control of RADseq datasets.
#' HWE can highligh genotyping errors, presence of null alleles,
#' sequence duplication, copy number variation and other sequencing problems
#' related to read depth.
#' This function is designed for
#' \strong{bi-allelic markers} and uses the exact test from the package
#' HardyWeinberg. The function is speedy because it uses the
#' C++ code developed by Christopher Chang and also available in PLINK.
#' The p-value generated by the function is the mid p-value. It's computed
#' as half the probability of the current sample + the probabilities of all
#' samples that are more extreme (see references below). Several output are
#' generated to help users filter the data (see details).
#'
#' Prior to HW filtering, I highly recommend removing outlier individuals,
#' filtering coverage and genotype likelihood (see details).


#' @param data A tidy data frame object in the global environment or
#' a tidy data frame in wide or long format in the working directory.
#' \emph{How to get a tidy data frame ?}
#' Look into \pkg{radiator} \code{\link{tidy_genomic_data}}.

#' @param interactive.filter (optional, logical) Do you want the filtering session to
#' be interactive. With default: \code{interactive.filter == TRUE}, the user is
#' asked to see figures of distribution before making decisions for filtering.

#' @param hw.pop.threshold (integer, optional)
#' Use this threshold to allow
#' variance in the number of populations passing the HWE test.
#' e.g. with \code{hw.pop.threshold = 2},
#' you tolerate a maximum of 2 populations that fails the HW test.
#' All markers with > 2 populations in HWD will be blacklisted.
#' With default, all populations need to be in HWE.
#' Default: \code{hw.pop.threshold = 0}.


#' @param midp.threshold (character, optional)
#' By default the function generates blacklists/whitelists of markers and
#' filtered tidy datasets for the 5 mid p-value.
#' However, to get a final filtered object associated with the output of the
#' function, user need to choose one
#' of the 5 mid p-value \code{"*", "**", "***", "****", "*****"}.
#' With default, a very conservative mid p-value threshold (= 0.0001) is selected.
#' Default: \code{midp.threshold = "****"}.

#' @param filename (optional) The function uses \code{\link[fst]{write.fst}},
#' to write the tidy data frame in
#' the folder created in the working directory. The file extension appended to
#' the \code{filename} provided is \code{.rad}.
#' Default: \code{filename = NULL}.

#' @inheritParams tidy_genomic_data

#' @rdname filter_hwe
#' @export
#' @importFrom ggplot2 ggplot aes geom_violin geom_boxplot stat_summary labs theme element_blank element_text geom_jitter scale_colour_manual scale_y_reverse theme_light geom_bar facet_grid geom_histogram geom_bar aes_string scale_fill_manual theme_bw stat_smooth geom_boxplot ggsave
#' @importFrom stringi stri_join stri_replace_all_fixed stri_sub stri_detect_fixed
#' @importFrom dplyr select distinct group_by ungroup rename arrange tally filter if_else mutate summarise left_join inner_join right_join anti_join semi_join full_join funs case_when
#' @importFrom readr write_tsv
#' @importFrom tibble data_frame has_name

#' @details
#' \strong{Interactive version}
#'
#' The user is asked to look at figures before choosing filter thresholds.
#'
#'
#' \strong{HWE threshold}
#'
#' I recommend starting with a low threshold.
#' Serious genotyping errors will generate extreme p-values (e.g. 1e-50),
#' which are detected by any reasonable configuration of this test,
#' while various life-history caracteristics will deflate/inflate
#' Hardy-Weinberg equilibrium.
#' Consequently, it's dangerous to choose a threshold that filters out too many
#' markers.
#'
#' \strong{strategies:}
#' Disk space is cheap! Consequently, the function will automatically generate
#' several blacklists/whitelists of markers and
#' filtered tidy data (in the directory)
#' based on the \code{hw.pop.threshold} for 4 groups of mid p-values:
#' \itemize{
#' \item MID_P_VALUE <= 0.00001: *****
#' \item MID_P_VALUE <= 0.0001: ****
#' \item MID_P_VALUE <= 0.001: ***
#' \item MID_P_VALUE <= 0.01: **
#' \item MID_P_VALUE <= 0.05: *
#' }
#'
#' Test the sensitivity of downstream analysis and delete unwanted datasets.
#'
#' \strong{missing data}
#'
#' The mid-p adjustment tends to bring the null rejection rate in line with the
#' nominal p-value, and also reduces the filter's tendency to favor retention
#' of SNPs with missing data (Graffelman and Moreno, 2013, Purcell et al., 2007).
#'
#' If pattern of missing data is present in the dataset, or when missing data
#' accross markers vary by more than 0.10, you should not apply a single mid-p-value
#' threshold accross markers.
#'
#' \strong{Read depth, pooling lanes/chips and weird pattern of individual heterozygosity}
#'
#' Because of read depth, heterozygote deficiency is usually observed in RADseq data,
#' but if sequencing lanes/chips were combined to generate individuals with more
#' coverage, the situation will likely be the reverse: heterozygote excess.
#' If lanes/chips pooling was used or if highly variable sequencing coverage is
#' observed between individuals and/or markers, there's a couple qc and filtering
#' steps you should do before conducting HWE filtering.
#'
#' \itemize{
#' \item run \pkg{radiator} \code{\link{detect_mixed_genomes}} and
#' \code{\link{detect_het_outliers}} to highlight
#' outlier individuals with potential heterozygosity problems and get an idea of
#' the genotyping and heterozygote miscall rate
#' \item I recommend normalizing the data before \emph{de novo} assembly, if this
#' is not possible...
#' \item use radiator::filter_rad or a more chirurgical approach to
#' coverage and genotype likelihood with radiator::filter_rad.
#' }
#'
#'
#' \strong{Permutation test}
#' Hardy-Weinberg equilibrium refers to the statistical independence of alleles
#' within individuals. This independence can also be assessed by permutation test
#' inside the HardyWeinberg package of Jan Graffelman. To filter out markers with
#' genotyping problems the approach provided in this function is enough.
#'
#' \strong{Power test for HWE}
#' Based on allele count/frequency and sample size. This function is longer to
#' generate for each markers and is on my todo list to include it in this filter.
#'
#'
#' \strong{Markers under selection and genome scans:}
#'
#' Scared of deleting those precious markers or that the filter might interfere
#' with genome scan analysis/detection ? Don't be. Your markers or analysis is no
#' good if it's done on bad data... Test the sensitivity of your downstream
#' analysis with the datasets generated with the different thresholds.


#' @note
#' \strong{Hardy-Weinberg assumptions (refresh):}
#' \enumerate{
#' \item Diploid organisms
#' \item Only reproduction sexual occurs
#' \item Generations are non-overlapping
#' \item Mating is random
#' \item Population size is infinitely large
#' \item Allele frequencies are equal in the sexes
#' \item Migration, Mutation and Selection are negligible
#' }
#'


#' @return A list in the global environment objects:
#' \enumerate{
#' \item $path.folder: the path to the folder generated.
#' \item $hw.pop.threshold: the number of populations tolerated to be in HWD before
#' blacklisting the markers.
#' \item $plot.hwd.thresholds: useful figure that highlight the number of markers
#' blacklisted based on the number of populations in HWD and mid p-value thresholds.
#' \item $plot.tern: ternary plot of markers.
#' \item $hw.manhattan: manhattan plot of markers in Hardy-Weinberg disequilibrium.
#' \item $hwe.pop.sum: a summary tibble with populations, number of markers in total,
#' number of markers monomorphic for the populations,
#' number of markers in Hardy-Weinberg Equilibrium (HWE),
#' number of markers in Hardy-Weinberg Dquilibrium (HWD) with all the different
#' mid p-values observed on the data.
#' \item $midp.threshold: the mid p-value threshold chosen for the final dataset (next)
#' \item $tidy.hw.filtered: the final filtered dataset (oter datasets \code{.rad}
#' are generated automatically by the function, check the folder)
#' }
#'
#' Written in the folder:
#' \enumerate{
#' \item genotypes.summary.tsv: A tibble with these columns:
#' \code{MARKERS, POP_ID, HET, HOM_ALT, HOM_REF, MISSING, N,
#' FREQ_ALT, FREQ_REF, FREQ_HET, FREQ_HOM_REF_O, FREQ_HET_O, FREQ_HOM_ALT_O,
#' FREQ_HOM_REF_E, FREQ_HET_E, FREQ_HOM_ALT_E, N_HOM_REF_EXP,
#' N_HET_EXP, N_HOM_ALT_EXP, HOM_REF_Z_SCORE, HOM_HET_Z_SCORE,
#' HOM_ALT_Z_SCORE, READ_DEPTH}

#' \item hw.pop.sum.tsv: a summary tibble with populations, number of markers in total,
#' number of markers monomorphic for the populations,
#' number of markers in Hardy-Weinberg Equilibrium (HWE),
#' number of markers in Hardy-Weinberg Dquilibrium (HWD) with all the different
#' mid p-values observed on the data.
#' \item hwd.helper.table.tsv: useful tibble that highlight the number of markers
#' blacklisted based on the number of populations in HWD and mid p-value thresholds.
#' \item hwd.plot.blacklist.markers.pdf: useful figure that highlight the number of markers
#' blacklisted based on the number of populations in HWD and mid p-value thresholds.
#' \item hwe.manhattan.plot.pdf: manhattan plot of markers in Hardy-Weinberg disequilibrium.
#' \item hwe.ternary.plots.missing.data.pdf: ternary plot of markers.
#' \item tidy.filtered.hwe.xxx.mid.p.value.xxx.hw.pop.threshold.rad: several
#' tidy dataset filtered with different mid p value and populations in HWD thresholds
#' \item whitelist.markers.hwe.xxx.mid.p.value.xxx.hw.pop.threshold.tsv: several
#' whitelist of  markers with different mid p value and populations in HWD thresholds
#' \item blacklist.markers.hwd.xxx.mid.p.value.xxx.hw.pop.threshold.tsv: several
#' blacklist of markers with different mid p value and populations in HWD thresholds
#' }
#'
#'


#' @examples
#' \dontrun{
#' require(HardyWeinberg)
#' require(ggtern)
#' library(radiator)
#' # for the interactive version (recommended)
#' turtle.pop <- radiator::filter_hwe(
#'    data = "turtle.vcf",
#'    strata = "turtle.strata.tsv",
#'    filename = "hwe.turtle"
#' )
#' }

#' @references Weir, B.S. (1996) Genetic data analysis II. Sinauer Associates,
#' Massachusetts. See Chapter3.
#'
#' @references Wigginton, J.E., Cutler, D.J. and Abecasis, G.R. (2005)
#' A note on exact tests of Hardy-Weinberg equilibrium,
#' American Journal of Human Genetics (76) pp. 887-893.
#'
#' @references Purcell et al. (2007) PLINK: A Toolset for Whole-Genome Association
#' and Population-Based Linkage Analysis.
#' American Journal of Human Genetics 81(3) pp. 559-575.
#'
#' @references Graffelman, J. and Moreno, V. (2013) The mid p-value in exact
#' tests for Hardy-Weinberg equilibrium, Statistical Applications in Genetics
#' and Molecular Biology 12(4) pp. 433-448.
#'
#' @references Graffelman J, Jain D, Weir B (2017)
#' A genome-wide study of Hardy-Weinberg equilibrium with next generation
#' sequence data. Human Genetics, 136, 727-741.


filter_hwe <- function(
  interactive.filter = TRUE,
  data,
  strata = NULL,
  hw.pop.threshold = 0,
  midp.threshold = "****",
  filename = NULL,
  blacklist.id = NULL,
  whitelist.markers = NULL,
  pop.levels = NULL,
  pop.labels = NULL,
  pop.select = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE
) {
  # required package
  if (!requireNamespace("HardyWeinberg", quietly = TRUE)) {
    stop("HardyWeinberg package needed for this function to work
         Install with install.packages('HardyWeinberg')", call. = FALSE)
  }

  if (!requireNamespace("ggtern", quietly = TRUE)) {
    stop("ggtern package needed for this function to draw ternary plots
         Install with install.packages('ggtern')", call. = FALSE)
  }
  if (verbose) {
    cat("#######################################################################\n")
    cat("####################### radiator::filter_hwe ##########################\n")
    cat("#######################################################################\n")
  }
  opt.change <- getOption("width")
  options(width = 70)
  timing <- proc.time()
  res <- list()

  # manage missing arguments -----------------------------------------------------
  if (missing(data)) stop("Input file missing")

  # Message about steps taken during the process ---------------------------------
  if (interactive.filter) {
    message("Interactive mode: on")
    if (hw.pop.threshold > 0) {
      message("Disabling hw.pop.threshold value")
      message("   you'll have to enter the value manually after visualization")
    }
  }
  # folder ---------------------------------------------------------------------
  # Get date and time to have unique filenaming
  file.date <- format(Sys.time(), "%Y%m%d@%H%M")
  folder.extension <- stringi::stri_join("filter_hwe_", file.date, sep = "")
  path.folder <- file.path(getwd(), folder.extension)
  dir.create(path.folder)
  if (verbose) message(stringi::stri_join("Folder created: ", folder.extension))
  file.date <- NULL #unused object

  # Filter parameter file ------------------------------------------------------
  message("Parameters used in this run are stored in a file")
  filters.parameters.path <- list.files(
    path = getwd(), pattern = "filters_parameters.tsv", full.names = TRUE)
  if (length(filters.parameters.path) == 0) {
    filters.parameters.path <- file.path(path.folder, "filters_parameters.tsv")
    filters.parameters <- tibble::data_frame(
      FILTERS = as.character(),
      PARAMETERS = as.character(),
      VALUES = as.integer(),
      BEFORE = as.character(),
      AFTER = as.character(),
      BLACKLIST = as.integer(),
      UNITS = as.character(),
      COMMENTS = as.character()) %>%
      readr::write_tsv(x = .,
                       path = filters.parameters.path,
                       append = FALSE, col_names = TRUE)
    message("    File written: filters_parameters.tsv")
  } else {
    message("    Using the filters parameters file: filters_parameters.tsv")
  }
  # File type detection----------------------------------------------------------
  data.type <- radiator::detect_genomic_format(data)

  if (data.type %in% c("tbl_df", "fst.file")) {
    message("    using tidy data frame of genotypes as input")
    message("    skipping all filters")

    if (data.type == "fst.file") {
      data <- radiator::read_rad(data)
    }
  } else {
    data <- radiator::tidy_genomic_data(
      data = data,
      vcf.metadata = TRUE,
      blacklist.id = blacklist.id,
      blacklist.genotype = NULL,
      whitelist.markers = whitelist.markers,
      strata = strata,
      pop.levels = pop.levels,
      pop.labels = pop.labels,
      pop.select = pop.select,
      filename = NULL,
      parallel.core = parallel.core,
      verbose = FALSE
    )
  }

  # create a strata.df
  strata <- data %>%
    dplyr::select(INDIVIDUALS, POP_ID) %>%
    dplyr::distinct(INDIVIDUALS, .keep_all = TRUE)

  # Check that data is biallelic -----------------------------------------------
  biallelic <- radiator::detect_biallelic_markers(data, parallel.core = parallel.core)
  if (!biallelic) stop("This filter requires bi-allelic data")

  # prepare filter, table and figure--------------------------------------------
  if (verbose) message("Summarizing data")
  sample.size <- dplyr::n_distinct(data$INDIVIDUALS)

  want <- c("MARKERS", "POP_ID", "N", "MISSING", "HOM_REF", "HET", "HOM_ALT", "READ_DEPTH")
  data.sum <- suppressWarnings(
    summarise_genotypes(data, path.folder = path.folder) %>%
      dplyr::select(dplyr::one_of(want)) %>%
      dplyr::rename(AA = HOM_REF, AB = HET, BB = HOM_ALT))
  pop.levels <- levels(data.sum$POP_ID)
  n.pop <- length(pop.levels)
  if (verbose) message("File written: genotypes.summary.tsv")

  # HWE analysis ---------------------------------------------------------------
  # data.bk <- data
  # data <- data.bk
  data.sum <- hwe_analysis(x = data.sum, parallel.core = parallel.core) %>%
    dplyr::mutate(
      POP_ID = factor(POP_ID, levels = pop.levels),
      GROUPINGS = factor(
        x = GROUPINGS,
        levels = c("monomorphic", "hwe", "*", "**", "***", "****", "*****"),
        labels = c("monomorphic", "hwe",
                   "midp <= 0.05 (*)",
                   "midp <= 0.01 (**)",
                   "midp <= 0.001 (***)",
                   "midp <= 0.0001 (****)",
                   "midp <= 0.00001 (*****)")),
      MISSING_PROP = MISSING / (MISSING + N)
    )
  # Step 1. Impact of population threshold on marker discovery------------------
  prop_join <- function(x, y) {
    stringi::stri_join(x, " (", round(x / y, 3), ")")
  }

  hwe.pop.sum <- data.sum %>%
    dplyr::group_by(POP_ID) %>%
    dplyr::summarise(
      MARKERS_TOTAL = length(MARKERS),
      MONOMORPHIC = length(MARKERS[MONO]),
      HWE = length(MARKERS[HWE & !is.na(HWE)]),
      `HWD*` = length(MARKERS[`*` & !is.na(`*`)]),
      `HWD**` = length(MARKERS[`**` & !is.na(`**`)]),
      `HWD***` = length(MARKERS[`***` & !is.na(`***`)]),
      `HWD****` = length(MARKERS[`****` & !is.na(`****`)]),
      `HWD*****` = length(MARKERS[`****` & !is.na(`*****`)])
    ) %>%
    dplyr::ungroup(.) %>%
    readr::write_tsv(x = ., path = file.path(path.folder, "hw.pop.sum.tsv"))
  if (verbose) message("File written: hw.pop.sum.tsv")

  hwd.markers.pop.sum <- data.sum %>%
    dplyr::filter(!HWE, POP_ID != "OVERALL") %>%
    dplyr::select(POP_ID, MARKERS, `*`, `**`, `***`, `****`, `*****`) %>%
    data.table::as.data.table(.) %>%
    data.table::melt.data.table(
      data = ., id.vars = c("MARKERS", "POP_ID"),
      variable.name = "SIGNIFICANCE", value.name = "VALUE",
      variable.factor = FALSE) %>%
    tibble::as_data_frame(.) %>%
    dplyr::mutate(
      SIGNIFICANCE = factor(SIGNIFICANCE,
                            levels = c("*", "**", "***", "****", "*****"))) %>%
    dplyr::filter(VALUE) %>%
    dplyr::group_by(MARKERS, SIGNIFICANCE) %>%
    dplyr::tally(.) %>%
    dplyr::rename(N_POP_HWD = n)

  n.markers <- dplyr::n_distinct(data$MARKERS)
  `Exact test mid p-value` <- NULL

  # hwd.helper.table.long <- data.sum %>%
  #   dplyr::filter(!HWE) %>%
  #   dplyr::select(POP_ID, MARKERS, `*`, `**`, `***`, `****`, `*****`) %>%
  #   data.table::as.data.table(.) %>%
  #   data.table::melt.data.table(
  #     data = ., id.vars = c("MARKERS", "POP_ID"),
  #     variable.name = "SIGNIFICANCE", value.name = "VALUE",
  #     variable.factor = FALSE) %>%
  #   tibble::as_data_frame(.) %>%
  #   dplyr::mutate(
  #     SIGNIFICANCE = factor(
  #       x = SIGNIFICANCE,
  #       levels = c("*", "**", "***", "****", "*****"),
  #       labels = c("midp <= 0.05 (*)", "midp <= 0.01 (**)",
  #                  "midp <= 0.001 (***)", "midp <= 0.0001 (****)",
  #                  "midp <= 0.00001 (*****)"))
  #   ) %>%
  #   dplyr::filter(VALUE)

  # overall <- hwd.helper.table.long %>%
  #   dplyr::filter(POP_ID == "OVERALL") %>%
  #   dplyr::group_by(MARKERS, SIGNIFICANCE) %>%
  #   dplyr::tally(.) %>%
  #   dplyr::rename(N_POP_HWD = n) %>%
  #   dplyr::group_by(SIGNIFICANCE, N_POP_HWD) %>%
  #   dplyr::tally(.) %>%
  #   dplyr::ungroup(.) %>%
  #   dplyr::mutate(N_POP_HWD = "OVERALL")

  overall <- data.sum %>%
    dplyr::filter(!HWE, POP_ID == "OVERALL") %>%
    dplyr::select(POP_ID, MARKERS, `*`, `**`, `***`, `****`, `*****`) %>%
    data.table::as.data.table(.) %>%
    data.table::melt.data.table(
      data = ., id.vars = c("MARKERS", "POP_ID"),
      variable.name = "SIGNIFICANCE", value.name = "VALUE",
      variable.factor = FALSE) %>%
    tibble::as_data_frame(.) %>%
    dplyr::mutate(SIGNIFICANCE = factor(SIGNIFICANCE,
                                        levels = c("*", "**", "***", "****", "*****"))) %>%
    dplyr::filter(VALUE) %>%
    dplyr::group_by(MARKERS, SIGNIFICANCE) %>%
    dplyr::tally(.) %>%
    dplyr::rename(N_POP_HWD = n) %>%
    dplyr::group_by(SIGNIFICANCE, N_POP_HWD) %>%
    dplyr::tally(.) %>%
    dplyr::ungroup(.) %>%
    dplyr::mutate(N_POP_HWD = "OVERALL")

  # hwd.helper.table.long <- hwd.helper.table.long %>%
  #   dplyr::filter(POP_ID != "OVERALL") %>%
  #   dplyr::group_by(MARKERS, SIGNIFICANCE) %>%
  #   dplyr::tally(.) %>%
  #   dplyr::rename(N_POP_HWD = n) %>%
  #   dplyr::group_by(SIGNIFICANCE, N_POP_HWD) %>%
  #   dplyr::tally(.) %>%
  #   dplyr::ungroup(.) %>%
  #   dplyr::mutate(N_POP_HWD = as.character(N_POP_HWD)) %>%
  #   dplyr::bind_rows(overall) %>%
  #   dplyr::mutate(
  #     N_POP_HWD = factor(
  #       x = N_POP_HWD, levels = c("OVERALL", 1:(n.pop -1)))
  #   )

  hwd.helper.table.long <- hwd.markers.pop.sum %>%
    dplyr::group_by(SIGNIFICANCE, N_POP_HWD) %>%
    dplyr::tally(.) %>%
    dplyr::ungroup(.) %>%
    dplyr::mutate(N_POP_HWD = as.character(N_POP_HWD)) %>%
    dplyr::bind_rows(overall) %>%
    dplyr::mutate(
      N_POP_HWD = factor(
        x = N_POP_HWD, levels = c("OVERALL", 1:(n.pop -1)))
    ) %>%
    tidyr::complete(
      data = .,
      SIGNIFICANCE, N_POP_HWD,
      fill = list(n = 0))

  overall <- NULL

  hwd.helper.table <- hwd.helper.table.long %>%
    # tidyr::complete(
    #   data = .,
    #   SIGNIFICANCE, N_POP_HWD,
    #   fill = list(n = 0)) %>%
    dplyr::group_by(N_POP_HWD) %>%
    tidyr::spread(data = ., key = SIGNIFICANCE, value = n) %>%
    dplyr::filter(N_POP_HWD != 0) %>%
    dplyr::ungroup(.) %>%
    readr::write_tsv(x = ., path = file.path(path.folder, "hwd.helper.table.tsv"))

  hwd.helper.table.long <- hwd.helper.table.long %>%
    dplyr::rename(`Exact test mid p-value` = SIGNIFICANCE)

  # dot plot with thresholds ---------------------------------------------------
  #Function to replace plyr::round_any
  rounder <- function(x, accuracy, f = round) {
    f(x / accuracy) * accuracy
  }

  max.markers <- max(hwd.helper.table.long$n)
  if (max.markers >= 1000) {
    y.breaks.by <- rounder(max.markers/10, 100, ceiling)
    y.breaks.max <- rounder(max.markers, 1000, ceiling)
    y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
  } else {
    y.breaks.by <- rounder(max.markers/10, 10, ceiling)
    y.breaks.max <- rounder(max.markers, 100, ceiling)
    y.breaks <- seq(0, y.breaks.max, by = y.breaks.by)
  }

  plot.hwd.thresholds <- ggplot2::ggplot(
    data = hwd.helper.table.long,
    ggplot2::aes(x = N_POP_HWD, y = n, colour = `Exact test mid p-value`, group = `Exact test mid p-value`)) +
    ggplot2::geom_point(size = 2, shape = 21, fill = "white") +
    ggplot2::geom_line() +
    # ggplot2::scale_x_continuous(name = "Number of populations in HWD", breaks = 1:n.pop - 1) +
    ggplot2::scale_y_continuous(name = "Number of markers blacklisted", breaks = y.breaks, limits = c(0, y.breaks.max)) +
    ggplot2::labs(
      x = "Number of populations in HWD",
      title = "Number of markers blacklisted based on the number of populations in HWD\nand mid p-value thresholds") +
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
      axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
      axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
      axis.text.x = ggplot2::element_text(size = 8, family = "Helvetica"),# , angle = 90, hjust = 1, vjust = 0.5),
      strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
    )
  # plot.hwd.thresholds
  if (interactive.filter) print(plot.hwd.thresholds)

  ggplot2::ggsave(
    limitsize = FALSE,
    plot = plot.hwd.thresholds,
    filename = file.path(path.folder, "hwd.plot.blacklist.markers.pdf"),
    width = n.pop * 5, height = 10,
    dpi = 300, units = "cm", useDingbats = FALSE)
  hwd.helper.table.long <- NULL
  if (verbose) message("Plot written: hwd.plot.blacklist.markers.pdf")

  # if (interactive.filter) {
  #   message("Step 1. Ternary plot visualization")
  # }
  # HardyWeinberg::HWTernaryPlot(
  # X = dplyr::filter(data, POP_ID == "ATL") %>%
  # dplyr::select(AA, AB, BB) %>% as.matrix, n = sample.size,
  # region = 1,
  # hwcurve = TRUE,
  # verbose = TRUE)

  # testing with duplicated info removed
  # data.dup <- data2 %>%
  #   dplyr::distinct(MARKERS, AA, AB, BB)

  # ternary plot -----------------------------------------------------------------
  # library(ggtern)
  num.groups <- dplyr::n_distinct(data.sum$GROUPINGS)
  if (num.groups == 7) group_colors <- c("grey", "green", "yellow", "orange",
                                         "orangered", "red", "darkred")
  if (num.groups == 6) group_colors <- c("green", "yellow", "orange",
                                         "orangered", "red", "darkred")

  # HW Parabola
  parabola <- tibble::tibble(p = seq(0, 1, by = 0.005)) %>%
    dplyr::mutate(AA = p^2, AB = 2 * p * (1 - p), BB = (1 - p)^2, p = NULL)
  sample.size <- data.sum %>% dplyr::group_by(POP_ID) %>%
    dplyr::summarise(NN = 2* max(N, na.rm = TRUE))

  hw_parabola <- function(x, sample.size, parabola) {
    pop <- unique(x)
    pop.size <- sample.size$NN[sample.size$POP_ID == pop]
    parabola <- parabola %>%
      dplyr::mutate(
        POP_ID = pop,
        NN = pop.size,
        AA = AA * NN,
        AB = AB * NN,
        BB = BB * NN,
        NN = NULL,
        GROUPINGS = "hwe",
        MISSING_PROP = 0)
    return(parabola)
  }

  hw.parabola <- purrr::map_df(.x = pop.levels, .f = hw_parabola,
                               sample.size = sample.size, parabola = parabola) %>%
    dplyr::mutate(POP_ID = factor(POP_ID, pop.levels))
  parabola <- sample.size <- NULL

  plot.tern <- ggtern::ggtern(
    data = data.sum,
    ggtern::aes(AA, AB, BB, color = GROUPINGS, size = MISSING_PROP)) +
    ggplot2::scale_color_manual(name = "Exact test mid p-value", values = group_colors) +
    ggplot2::scale_size_continuous(name = "Missing genotypes proportion") +
    ggtern::theme_rgbw() +
    ggplot2::geom_point(alpha = 0.4) +
    ggplot2::geom_line(data = hw.parabola, ggplot2::aes(x = AA, y = AB),
                       linetype = 2, size = 0.6, colour = "black") +
    ggtern::theme_nogrid_minor() +
    ggtern::theme_nogrid_major() +
    ggplot2::labs(
      x = "AA", y = "AB", z = "BB",
      title = "Hardy-Weinberg Equilibrium ternary plots",
      subtitle = "genotypes frequencies shown for AA: REF/REF, AB: REF/ALT and BB: ALT/ALT"
    ) +
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
      plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5)
    ) +
    ggplot2::facet_wrap(~ POP_ID)
  # plot.tern
  ggtern::ggsave(
    limitsize = FALSE,
    plot = plot.tern,
    # filename = file.path(path.folder, "hwe.ternary.plots.read.depth.pdf"),
    filename = file.path(path.folder, "hwe.ternary.plots.missing.data.pdf"),
    width = n.pop * 5, height = n.pop * 4,
    dpi = 300, units = "cm", useDingbats = FALSE)
  hw.parabola <- NULL
  if (verbose) message("Plot written: hwe.ternary.plots.missing.data.pdf")

  # Manhattan plot -------------------------------------------------------------
  data.sum.man <- dplyr::mutate(data.sum, X = "x") %>% dplyr::filter(MID_P_VALUE < 0.05)
  # rounder <- function(x, accuracy, f = round) {
  #   f(x / accuracy) * accuracy
  # }
  # y.breaks.by <- rounder(max(data.sum$MID_P_VALUE, na.rm = TRUE)/10, 0.001, ceiling)
  # y.breaks.max <- rounder(max(data.sum$MID_P_VALUE, na.rm = TRUE), 0.001, ceiling) + (y.breaks.by / 2)
  # y.breaks.min <- rounder(min(data.sum$MID_P_VALUE, na.rm = TRUE), 0.001, ceiling) - (y.breaks.by / 2)
  # y.breaks <- seq(y.breaks.min, y.breaks.max, by = y.breaks.by)

  num.groups <- dplyr::n_distinct(data.sum.man$GROUPINGS)
  if (num.groups == 5) group_colors <- c("yellow", "orange", "orangered", "red", "darkred")
  if (num.groups == 4) group_colors <- c("yellow", "orange", "orangered", "red")

  hw.manhattan <- ggplot2::ggplot(
    data = data.sum.man,
    ggplot2::aes(x = X, y = MID_P_VALUE, color = GROUPINGS, size = MISSING_PROP)) +
    ggplot2::geom_jitter(alpha = 0.5) +
    ggplot2::scale_color_manual(name = "Exact test mid p-value", values = group_colors) +
    ggplot2::scale_size_continuous(name = "Missing genotypes proportion") +
    ggplot2::labs(
      y = "Markers mid p-value",
      title = "Manhanttan plot of markers in Hardy-Weinberg disequilibrium"
    ) +
    ggplot2::theme_bw()+
    ggplot2::theme(
      panel.grid.major.x = ggplot2::element_blank(),
      plot.title = ggplot2::element_text(size = 12, family = "Helvetica", face = "bold", hjust = 0.5),
      plot.subtitle = ggplot2::element_text(size = 10, family = "Helvetica", hjust = 0.5),
      axis.line.x = ggplot2::element_blank(),
      axis.title.x = ggplot2::element_blank(),
      axis.text.x = ggplot2::element_blank(),
      axis.ticks.x = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
      axis.text.y = ggplot2::element_text(size = 8, family = "Helvetica")
    ) +
    ggplot2::facet_grid(GROUPINGS ~ POP_ID, scales = "free")

  # if (interactive.filter) print(hw.manhattan)
  ggplot2::ggsave(
    filename = file.path(path.folder, "hwe.manhattan.plot.pdf"),
    plot = hw.manhattan,
    width = 5 * n.pop, height = 30,
    dpi = 600, units = "cm", useDingbats = FALSE, limitsize = FALSE)
  if (verbose) message("Plot written: hwe.manhattan.plot.pdf")

  # generate the blacklist/whitelist -------------------------------------------
  # Generate blacklist of markers with the 4 significance groups
  # threshold (integer) The number of outlier pop you tolerate to deviate from HWE.
  # e.g. if \code{threshold = 2}, blacklist of markers out of HWE in more than (>=)
  # 2 populations will be generated for all significance groupings.

  #leave user with this figure before choosing threshold

  if (interactive.filter) {
    message("\nBased on figures and tables enter the hw.pop.threshold")
    message("    an integer (e.g. 4):")
    hw.pop.threshold <- as.numeric(readLines(n = 1))
  }

  # hw.pop.threshold <- 8
  # Generating blacklists, whitelists and filtered tidy data -------------------
  if (verbose) message("\nGenerating blacklists, whitelists and filtered tidy data")
  output.message <- blacklist_hw(
    hwd.markers.pop.sum, data, hw.pop.threshold, path.folder, filters.parameters.path) %>%
    dplyr::select(-FILTERS, -COMMENTS)

  res = list(path.folder = path.folder,
             hw.pop.threshold = hw.pop.threshold,
             plot.hwd.thresholds = plot.hwd.thresholds,
             plot.tern = plot.tern,
             hw.manhattan = hw.manhattan,
             hwe.pop.sum = hwe.pop.sum)

  # Choosing the last dataset --------------------------------------------------
  no.file <- TRUE
  while (no.file) {
    if (interactive.filter) {
      message("\nChoosing the final filtered dataset")
      message("   the tidy data object associated with this filter...")
      message("   choose the mid p-value threshold (one of: *, **, ***, **** or *****)")
      midp.threshold <- as.character(readLines(n = 1))
    }
    midp.threshold <- dplyr::case_when(
      midp.threshold == "*****" ~ 0.00001,
      midp.threshold == "****" ~ 0.0001,
      midp.threshold == "***" ~ 0.001,
      midp.threshold == "**" ~ 0.01,
      midp.threshold == "*" ~ 0.05) %>%
      format(., scientific = FALSE)

    # path.folder <- yft.hw$path.folder
    data.filtered.name <- list.files(
      path = path.folder,
      pattern = stringi::stri_join("tidy.filtered.hwe.", midp.threshold),
      full.names = FALSE)
    if (length(data.filtered.name) == 0) {
      message("No file associated with this threshold, choose again")
      no.file <- TRUE
    } else {
      no.file <- FALSE
    }
  }

  res$midp.threshold  <- midp.threshold

  message("\nFinal filtered tidy dataset: \n", data.filtered.name)
  message("\nUsing hw.pop.threshold/midp.threshold: ", hw.pop.threshold, "/", midp.threshold)

  res$tidy.hw.filtered <- list.files(
    path = path.folder,
    pattern = stringi::stri_join("tidy.filtered.hwe.", midp.threshold),
    full.names = TRUE) %>%
    radiator::read_rad(data = .)

  # results --------------------------------------------------------------------
  if (verbose) {
    cat("############################### RESULTS ###############################\n")
    message("with hw.pop.threshold: ", "> ", hw.pop.threshold)
    # message("The number of markers (SNP/LOCUS) before -> blacklisted -> after the HWE filter:\n", markers.before, " -> ", markers.after)

    print(output.message)

    timing <- proc.time() - timing
    message("\nComputation time: ", round(timing[[3]]), " sec")
    cat("############################## completed ##############################\n")
  }
  options(width = opt.change)
  return(res)
}

# Internal nested functions ----------------------------------------------------

# hwe analysis
#' @title hwe_analysis
#' @description main hwe function
#' @rdname hwe_analysis
#' @keywords internal
#' @export
#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

# Note to myself: will have to enable an option that generate different datasets
# to build confidence interval
# permuting populations


hwe_analysis <- function(x, parallel.core = parallel::detectCores() - 1) {
  hwe_map <- function(x, parallel.core) {
    pop <- as.character(unique(x$POP_ID))
    message("HWE analysis for pop: ", pop)
    if (tibble::has_name(x, "POP_ID")) x <- dplyr::select(x, -POP_ID)
    hwe_radiator <- function(x) {
      if (tibble::has_name(x, "SPLIT_VEC")) x <- dplyr::select(x, -SPLIT_VEC)
      mono <- function(x) {
        mono <- length(x$AA[x$AA == 0]) + length(x$AB[x$AB == 0]) + length(x$BB[x$BB == 0])
        if (mono >= 2) {
          mono <- TRUE
        } else {
          mono <- FALSE
        }
        return(mono)
      }

      hw.res <- x %>%
        dplyr::bind_cols(dplyr::rowwise(.) %>% dplyr::do(MONO = mono(.))) %>%
        dplyr::mutate(MONO = unlist(MONO))
      hw.poly <- dplyr::filter(hw.res, !MONO) %>%
        dplyr::select(-MONO)
      markers <- dplyr::select(hw.poly, MARKERS)
      hw.poly <- dplyr::select(hw.poly, AA, AB, BB) #%>% as.matrix

      hw.res <- dplyr::left_join(
        hw.res,
        dplyr::bind_cols(
          markers,
          tibble::data_frame(
            MID_P_VALUE = HardyWeinberg::HWExactStats(
              X = hw.poly, plinkcode = TRUE, midp = TRUE)
          )
        )
        , by = "MARKERS") %>%
        dplyr::mutate(
          HWE = MID_P_VALUE >= 0.05,
          SIGNIFICANCE = dplyr::case_when(
            MID_P_VALUE <= 0.00001 ~ "*****",
            MID_P_VALUE <= 0.0001 ~ "****",
            MID_P_VALUE <= 0.001 ~ "***",
            MID_P_VALUE <= 0.01 ~ "**",
            MID_P_VALUE <= 0.05 ~ "*"),
          `*` = MID_P_VALUE <= 0.05,
          `**` = MID_P_VALUE <= 0.01,
          `***` = MID_P_VALUE <= 0.001,
          `****` = MID_P_VALUE <= 0.0001,
          `*****` = MID_P_VALUE <= 0.00001,
          GROUPINGS = SIGNIFICANCE,
          GROUPINGS = dplyr::if_else(
            MONO, "monomorphic",
            dplyr::if_else(HWE, "hwe", GROUPINGS))
        ) %>%
        tibble::add_column(.data = ., POP_ID = pop, .after = 1)
      return(hw.res)
    }#hwe_radiator
    x <-  x %>%
      dplyr::mutate(SPLIT_VEC = split_vec_row(x = ., cpu.rounds = 10,
                                              parallel.core = parallel.core)) %>%
      split(x = ., f = .$SPLIT_VEC) %>%
      .radiator_parallel(X = ., FUN = hwe_radiator, mc.cores = parallel.core) %>%
      dplyr::bind_rows(.)
    return(x)
  }#hwe_map

  x <- x %>% split(x = ., f = .$POP_ID) %>%
    purrr::map_df(.x = ., .f = hwe_map, parallel.core = parallel.core)
}#hwe_analysis

#' @title blacklist_hw
#' @description blacklist hw
#' @rdname blacklist_hw
#' @keywords internal
#' @export
#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

blacklist_hw <- function(x, unfiltered.data, hw.pop.threshold, path.folder = NULL,
                         filters.parameters.path) {
  if (is.null(path.folder)) path.folder <- getwd()

  x <- dplyr::ungroup(x) %>%
    dplyr::filter(N_POP_HWD > hw.pop.threshold)

  bl_map <- function(x, unfiltered.data, hw.pop.threshold,
                     path.folder, filters.parameters.path) {

    if (nrow(x) > 0) {
      significance.group <- unique(x$SIGNIFICANCE)
      # significance.group <-  "****"
      # system.time(significance.group1 <- stringi::stri_replace_all_regex(
      #   str = significance.group,
      #   pattern = c("^\\*\\*\\*\\*$", "^\\*\\*\\*$", "^\\*\\*$","^\\*$"),
      #   replacement = c("0.0001", "0.001", "0.01", "0.05"),
      #   vectorize_all = FALSE
      # ))

      significance.group <- dplyr::case_when(
        significance.group == "*****" ~ 0.00001,
        significance.group == "****" ~ 0.0001,
        significance.group == "***" ~ 0.001,
        significance.group == "**" ~ 0.01,
        significance.group == "*" ~ 0.05) %>%
        format(., scientific = FALSE)

      blacklist.filename <- file.path(
        path.folder,
        stringi::stri_join(
          "blacklist.markers.hwd", significance.group, "mid.p.value",
          hw.pop.threshold, "hw.pop.threshold", "tsv", sep = "."))

      whitelist.filename <- file.path(
        path.folder,
        stringi::stri_join(
          "whitelist.markers.hwe", significance.group, "mid.p.value",
          hw.pop.threshold, "hw.pop.threshold", "tsv", sep = "."))

      rad.filename <- file.path(
        path.folder,
        stringi::stri_join(
          "tidy.filtered.hwe", significance.group, "mid.p.value",
          hw.pop.threshold, "hw.pop.threshold", "rad", sep = "."))

      # Generate the blacklist
      want <- c("MARKERS", "CHROM", "LOCUS", "POS")
      blacklist <- suppressWarnings(
        dplyr::distinct(x, MARKERS) %>%
          dplyr::left_join(
            dplyr::select(unfiltered.data, dplyr::one_of(want)) %>%
              dplyr::distinct(MARKERS, .keep_all = TRUE)
            , by = "MARKERS") %>%
          readr::write_tsv(
            x = .,
            path = blacklist.filename)
      )


      # Generate the rad data + the whitelist
      whitelist <- suppressWarnings(
        unfiltered.data %>%
          dplyr::filter(!MARKERS %in% blacklist$MARKERS) %>%
          radiator::write_rad(data = ., path = rad.filename) %>%
          dplyr::select(dplyr::one_of(want)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
          readr::write_tsv(x = ., path = whitelist.filename)
      )
      fil.param <- update_filter_parameter(
        filter = "HWE",
        unfiltered = unfiltered.data,
        filtered = whitelist,
        parameter = "hw.pop.threshold/mid.p.value",
        threshold = stringi::stri_join(hw.pop.threshold, significance.group, sep = "/"),
        param.path = filters.parameters.path)
    }
  }#End bl_map
  split(x = x, f = x$SIGNIFICANCE) %>%
    purrr::walk(
      .x = ., .f = bl_map,
      unfiltered.data = unfiltered.data,
      hw.pop.threshold = hw.pop.threshold,
      path.folder = path.folder,
      filters.parameters.path = filters.parameters.path)
  fil.param <- readr::read_tsv(file = filters.parameters.path, col_types = "cccccccc") %>%
    dplyr::filter(FILTERS == "HWE")
  return(fil.param)
}#End blacklist_hw

#' @title update filter parameter file
#' @description update filter parameter file
#' @rdname update_filter_parameter
#' @keywords internal
#' @export
#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}
update_filter_parameter <- function(filter, unfiltered,
                                    filtered, parameter,
                                    threshold, param.path) {
  # Update filters.parameters SNP ----------------------------------------------
  snp.before <- as.integer(dplyr::n_distinct(unfiltered$MARKERS))
  snp.after <- as.integer(dplyr::n_distinct(filtered$MARKERS))
  snp.blacklist <- snp.before - snp.after

  if (tibble::has_name(unfiltered, "LOCUS")) {
    locus.before <- as.integer(dplyr::n_distinct(unfiltered$LOCUS))
    locus.after <- as.integer(dplyr::n_distinct(filtered$LOCUS))
    locus.blacklist <- locus.before - locus.after
  } else {
    locus.before <- as.character("NA")
    locus.after <- as.character("NA")
    locus.blacklist <- as.character("NA")
  }


  markers.before <- stringi::stri_join(snp.before, locus.before, sep = "/")
  markers.after <- stringi::stri_join(snp.after, locus.after, sep = "/")
  markers.blacklist <- stringi::stri_join(snp.blacklist, locus.blacklist, sep = "/")

  filters.parameters <- tibble::data_frame(
    FILTERS = filter,
    PARAMETERS = parameter,
    VALUES = threshold,
    BEFORE = markers.before,
    AFTER = markers.after,
    BLACKLIST = markers.blacklist,
    UNITS = c("SNP/LOCUS"),
    COMMENTS = c("")
  ) %>%
    readr::write_tsv(x = ., path = param.path,
                     append = TRUE, col_names = FALSE)
  return(res = list(filters.parameters, markers.before, markers.blacklist, markers.after))
}#End update_filter_parameter

# testing
# test using nest and purrr map
# test <- data %>% dplyr::group_by(POP_ID) %>%
#   tidyr::nest(data = ., .key = "DATA") %>%
#   dplyr::filter(POP_ID %in% c("ATL", "MAL")) %>%
#   dplyr::mutate(ANALYSIS = purrr::map(.x = .$DATA, .f = hwe_analysis)) %>%
#   dplyr::select(-DATA) %>%
#   tidyr::unnest(.)

# test using furrr and future
# library(furrr)
# oplan <- future::plan()
# future::plan(multiprocess(workers = parallel.core))
#
# if (dplyr::n_distinct(data$POP_ID) > 2 * parallel.core) {
#   future.scheduling <- 2L
# } else {
#   future.scheduling <- 1L
# }
#
# system.time(
#   test <- data %>%
#     dplyr::filter(!POP_ID %in% c("OVERALL")) %>%
#     dplyr::group_by(POP_ID) %>%
#     tidyr::nest(data = ., .key = "DATA") %>%
#     dplyr::mutate(ANALYSIS = furrr::future_map(
#       .x = .$DATA,
#       .f = hwe_analysis,
#       .progress = TRUE,
#       future.scheduling = future.scheduling)) %>%
#     dplyr::select(-DATA) %>%
#     tidyr::unnest(.)
# )
# on.exit(plan(oplan), add = TRUE)
