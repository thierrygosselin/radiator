#' @name snp_ld
#' @title GBS/RADseq short distance linkage disequilibrium pruning
#' @description SNP short distance linkage disequilibrium pruning.
#' With anonymous markers from
#' RADseq/GBS de novo discovery, you can minimize linkage disequilibrium (LD) by
#' choosing among these 5 options (see argument below).
#'
#' For long distance linkage disequilibrium pruning, see details below.
#' This function is used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users.

#' @param data A tidy data set with ID (LOCUS) and POS (SNP) information.
#' \emph{How to get a tidy data frame ?}
#' Look into \pkg{radiator} \code{\link{tidy_genomic_data}}.
#' Usually the LOCUS and POS info is taken from a VCF file.

#' @param snp.ld (character) 5 options:
#' \enumerate{
#' \item \code{snp.ld = "random"} for a random selection of 1 SNP on the read,
#' \item \code{snp.ld = "first"} for the first one on the read...,
#' \item \code{snp.ld = "last"} for the last SNP on the read and
#' \item \code{snp.ld = "middle"} for locus with > 2 SNPs/read the option to select at random
#' one SNP between the first and the last SNP on the read. If the locus as <= 2
#' SNPs on the read, the first one is selected. Note that for that last option,
#' the numbers are reported.
#' \item \code{snp.ld = "maf"} will select the SNP on the locus with the maximum global
#' Minor Allele Frequency (MAF).
#' }
#' Default: \code{snp.ld = "maf"}.

#' @param maf.data (path) When \code{snp.ld = "maf"} is selected,
#' to speed up calculations, you can provide
#' the maf information generated by the function \code{\link{filter_maf}} or
#' let this function calculates it from the data (default).
#' Designated alternate allele embedded in the data are not taken for granted
#' and this information is re-computed from the data to get actual
#' minor allele frequency. MAF in this context is calculated only for locus with
#' multiple SNPs.
#' Default: \code{maf.data = NULL}.

#' @inheritParams tidy_genomic_data

#' @export
#' @rdname snp_ld


#' @importFrom stringi stri_replace_all_fixed stri_join
#' @importFrom tibble has_name
#' @importFrom dplyr select distinct group_by sample_n summarise semi_join n_distinct

snp_ld <- function(
  data,
  snp.ld = "maf",
  maf.data = NULL,
  parallel.core = parallel::detectCores() - 1
  ) {
  snp.ld <- match.arg(snp.ld, c("first", "random", "last", "middle", "maf"))

  # Checking for missing and/or default arguments ------------------------------
  if (missing(data)) stop("Input file missing")

  # Import data ---------------------------------------------------------------

  if (is.vector(data)) {
    data <- radiator::tidy_wide(data = data, import.metadata = FALSE)
  }

  # Check that fiel format as ID and POS -------------------------------------
  if (!tibble::has_name(data, "LOCUS") && !tibble::has_name(data, "POS")) {
    stop("snp.ld is only available for VCF file and/or files with ID and POS info")
  }

  message("Minimizing short distance LD...")
  message("    snp.ld = ", snp.ld)

  snp.locus <- dplyr::distinct(data, LOCUS, POS) %>% dplyr::arrange(LOCUS, POS)

  locus.stats <- dplyr::group_by(.data = snp.locus, LOCUS) %>%
    dplyr::tally(.) %>%
    dplyr::rename(SNP_N = n) %>%
    dplyr::group_by(SNP_N) %>%
    dplyr::tally(.)

  if (nrow(locus.stats) > 1) {
    range.number.snp.locus <- range(locus.stats$SNP_N, na.rm = TRUE)
    message("    The range in the number of SNP/locus is: ", stringi::stri_join(range.number.snp.locus, collapse = "-"))
  } else {
    message("    There is no variation in the number of SNP/locus across the data")
  }

  # Random selection ---------------------------------------------------------
  if (snp.ld == "random") {
    snp.select <- snp.locus %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::sample_n(tbl = ., size = 1, replace = FALSE)
    snp.before <- nrow(snp.locus)
    snp.after <- nrow(snp.select)
    message("    Number of SNP before = ", snp.before)
    message("    Number of SNP removed = ", snp.before - snp.after)
    message("    Number of SNP after = ", snp.after)
  }#End snp random

  # Fist SNP on the read -----------------------------------------------------
  if (snp.ld == "first") {
    snp.select <- snp.locus %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::summarise(POS = min(POS))
    snp.before <- nrow(snp.locus)
    snp.after <- nrow(snp.select)
    message("    Number of SNP before = ", snp.before)
    message("    Number of SNP removed = ", snp.before - snp.after)
    message("    Number of SNP after = ", snp.after)
  }#End snp first

  # Last SNP on the read -----------------------------------------------------
  if (snp.ld == "last") {
    snp.select <- snp.locus %>%
      dplyr::group_by(LOCUS) %>%
      dplyr::summarise(POS = max(POS))
    snp.before <- nrow(snp.locus)
    snp.after <- nrow(snp.select)
    message("    Number of SNP before = ", snp.before)
    message("    Number of SNP removed = ", snp.before - snp.after)
    message("    Number of SNP after = ", snp.after)
  }#End snp last

  # Middle SNP on the read -----------------------------------------------------
  if (snp.ld == "middle") {
    snp.locus.prep <- dplyr::group_by(.data = snp.locus, LOCUS) %>%
      dplyr::tally(.)

    pick.middle <- snp.locus.prep %>%
      dplyr::filter(n > 2) %>%
      dplyr::select(LOCUS)

    if (nrow(pick.middle) == 0) {
      message("IMPORTANT: the data doesn't have more than 3 SNPs per locus")
      message("    First SNP will be selected instead...")
      snp.select <- snp.locus %>%
        dplyr::group_by(LOCUS) %>%
        dplyr::summarise(POS = min(POS))
    } else {

      # For locus with <= 2 SNPs/read just keep the first one.
      keep.first <- snp.locus.prep %>%
        dplyr::filter(n <= 2) %>%
        dplyr::select(LOCUS)
      message("    Number of locus with first SNP selected: ", nrow(keep.first))
      keep.first.select <- snp.locus %>%
        dplyr::filter(LOCUS %in% keep.first$LOCUS) %>%
        dplyr::group_by(LOCUS) %>%
        dplyr::summarise(POS = min(POS))

      pick.middle.select <- snp.locus %>%
        dplyr::filter(LOCUS %in% pick.middle$LOCUS) %>%
        dplyr::group_by(LOCUS) %>%
        dplyr::filter(POS != min(POS)) %>% # remove the first SNP
        dplyr::filter(POS != max(POS)) %>% # remove the last SNP
        dplyr::sample_n(tbl = ., size = 1, replace = FALSE) # pick one at random

      message("    Number of locus with random middle SNP selected: ", nrow(pick.middle))
      snp.select <- dplyr::bind_rows(keep.first.select, pick.middle.select) %>%
        dplyr::arrange(LOCUS, POS)
    }
    snp.before <- nrow(snp.locus)
    snp.after <- nrow(snp.select)
    message("    Number of SNP before = ", snp.before)
    message("    Number of SNP removed = ", snp.before - snp.after)
    message("    Number of SNP after = ", snp.after)
  }#End snp middle

  # SNP with max MAF on the read -----------------------------------------------
  if (snp.ld == "maf") {
    snp.locus <- dplyr::distinct(data, MARKERS, LOCUS, POS)

    snp.select.no.maf <- dplyr::group_by(.data = snp.locus, LOCUS) %>%
      dplyr::tally(.) %>%
      dplyr::filter(n == 1) %>%
      dplyr::left_join(snp.locus, by = "LOCUS") %>%
      dplyr::select(-n) %>%
      dplyr::distinct(MARKERS, .keep_all = TRUE)


    if (is.null(maf.data)) {
      # calculate GLOBAL MAF per SNP/LOCUS
      if (tibble::has_name(data, "GT_BIN")) {
        markers.df <- dplyr::distinct(snp.locus, MARKERS) %>%
          dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS)
        n.markers <- nrow(markers.df)

        global_maf <- function(x) {
          maf.data <- dplyr::group_by(x, MARKERS) %>%
            dplyr::summarise(
              N = as.numeric(2 * n()),
              PP = as.numeric(2 * length(GT_BIN[GT_BIN == 0])),
              PQ = as.numeric(length(GT_BIN[GT_BIN == 1])),
              QQ = as.numeric(2 * length(GT_BIN[GT_BIN == 2]))
            ) %>%
            # need this step because seen cases where 2 is not the minor allele...
            dplyr::mutate(
              PP = PP + PQ,
              QQ = QQ + PQ,
              ALT = dplyr::if_else(PP < QQ, PP, QQ)) %>%
            dplyr::mutate(
              MAF_GLOBAL = (ALT / N),
              N = NULL, PP = NULL, QQ = NULL, PQ = NULL, ALT = NULL) %>%
            dplyr::ungroup(.)

          return(maf.data)
        }#End global_maf

        if (n.markers > 10000) {
          split.vec <- markers.df %>%
            dplyr::mutate(SPLIT_VEC = split_vec_row(
              markers.df,
              cpu.rounds = ceiling(n.markers/10000),
              parallel.core = parallel.core))

          maf.data <- data %>%
            dplyr::filter(!is.na(GT_BIN)) %>%
            dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS) %>%
            dplyr::left_join(split.vec, by = "MARKERS") %>%
            split(x = ., f = .$SPLIT_VEC) %>%
            .radiator_parallel_mc(
              X = .,
              FUN = global_maf,
              mc.cores = parallel.core
            ) %>%
            dplyr::bind_rows(.)
          markers.df <- split.vec <- NULL
        } else {
          maf.data <- global_maf(
            x = dplyr::filter(data, !is.na(GT_BIN)) %>%
              dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS)
          )
          # maf.data <- data %>%
          #   dplyr::filter(!is.na(GT_BIN)) %>%
          #   dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS) %>%
          #   dplyr::group_by(MARKERS) %>%
          #   dplyr::summarise(
          #     N = as.numeric(2 * n()),
          #     PP = as.numeric(2 * length(GT_BIN[GT_BIN == 0])),
          #     PQ = as.numeric(length(GT_BIN[GT_BIN == 1])),
          #     QQ = as.numeric(2 * length(GT_BIN[GT_BIN == 2]))
          #   ) %>%
          #   # need this step because seen cases where 2 is not the minor allele...
          #   dplyr::mutate(
          #     PP = PP + PQ,
          #     QQ = QQ + PQ,
          #     ALT = dplyr::if_else(PP < QQ, PP, QQ)) %>%
          #   dplyr::mutate(
          #     MAF_GLOBAL = (ALT / N),
          #     N = NULL, PP = NULL, QQ = NULL, PQ = NULL, ALT = NULL) %>%
          #   dplyr::ungroup(.)
        }
      } else {
        maf.data <- data %>%
          dplyr::filter(GT != "000000") %>%
          dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS) %>%
          dplyr::select(MARKERS, INDIVIDUALS, GT) %>%
          dplyr::mutate(
            A1 = stringi::stri_sub(GT, 1, 3),
            A2 = stringi::stri_sub(GT, 4,6)
          ) %>%
          dplyr::select(MARKERS, INDIVIDUALS, A1, A2) %>%
          tidyr::gather(data = ., key = ALLELES, value = GT, -c(MARKERS, INDIVIDUALS)) %>%
          dplyr::group_by(MARKERS, GT) %>%
          dplyr::tally(.) %>%
          dplyr::group_by(MARKERS) %>%
          dplyr::mutate(n.al.tot = sum(n)) %>%
          dplyr::filter(n == min(n)) %>%
          dplyr::distinct(MARKERS, .keep_all = TRUE) %>%
          dplyr::summarise(MAF_GLOBAL = n / n.al.tot) %>%
          dplyr::ungroup(.) %>%
          dplyr::select(MARKERS, MAF_GLOBAL)
      }

      snp.select.maf <- snp.locus %>%
        dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS) %>%
        dplyr::left_join(maf.data, by = "MARKERS") %>%
        dplyr::group_by(LOCUS) %>%
        dplyr::filter(MAF_GLOBAL == max(MAF_GLOBAL)) %>%
        dplyr::ungroup(.) %>%
        dplyr::distinct(LOCUS, .keep_all = TRUE)

    } else {
      snp.select.maf <- snp.locus %>%
        dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS) %>%
        dplyr::left_join(
          suppressWarnings(
            readr::read_tsv(file = maf.data, col_types = "c____d__") %>%
              dplyr::distinct(MARKERS, .keep_all = TRUE) #%>% dplyr::filter(!MARKERS %in% snp.select.no.maf$MARKERS)
          ), by = "MARKERS") %>%
        dplyr::group_by(LOCUS) %>%
        dplyr::filter(MAF_GLOBAL == max(MAF_GLOBAL)) %>%
        dplyr::ungroup(.) %>%
        dplyr::select(-MAF_GLOBAL) %>%
        dplyr::distinct(LOCUS, .keep_all = TRUE)
    }

    snp.select <- dplyr::distinct(snp.select.no.maf, LOCUS, POS) %>%
      dplyr::bind_rows(snp.select.maf)

    snp.before <- nrow(snp.locus)
    snp.after <- nrow(snp.select)
    message("    Number of SNP before = ", snp.before)
    message("    Number of SNP removed = ", snp.before - snp.after)
    message("    Number of SNP after = ", snp.after)
    snp.locus <- maf.data <- NULL
  }#End snp maf

  snp.select.maf <- snp.select.no.maf <- NULL
  # filtering the VCF to minimize LD -----------------------------------------
  data <- dplyr::semi_join(data, snp.select, by = c("LOCUS", "POS"))
  message("    Filtering the dataset to minimize LD by keeping only 1 SNP per locus")
  return(data)
}#End snp_ld
