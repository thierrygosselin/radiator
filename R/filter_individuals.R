# Filter/blacklist individuals

#' @name filter_individuals

#' @title Filter individuals based on genotyping/missingness rate,
#' heterozygosity and total coverage

#' @description Remove individuals with bad QC based on:
#' \itemize{
#' \item missingness (genotyping rate)
#' \item heterozygosity
#' \item coverage (total)
#' }
#'
#' \strong{Filter targets}: Individuals
#'
#' \strong{Statistics}: Missingness, heterozygosity and total coverage
#'
#' Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users who wants to blacklist individuals.

#' @param data (2 options) A Genomic Data Structure (GDS)
#' file or object generated by radiator.
#'
#' \emph{How to get GDS?}
#' Look into:
#' \code{\link{read_vcf}} or
#' \code{\link{tidy_vcf}}.


#' @param filter.individuals.missing (optional, double) A proportion above which the individuals are
#' blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.missing = NULL}.

#' @param filter.individuals.heterozygosity (optional, string of doubles) A proportion below and
#' above which the individuals are blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.heterozygosity = NULL}.

#' @param filter.individuals.coverage.total (optional, string of doubles) A proportion below and
#' above which the individuals are blacklisted and removed from the dataset.
#' Default: \code{filter.individuals.coverage.total = NULL}.

#' @inheritParams radiator_common_arguments

#' @return A list with the filtered input and blacklist of individuals.

#' @export
#' @rdname filter_individuals

#' @seealso
#' \code{\link{filter_rad}}
#' \code{\link{tidy_genomic_data}}, \code{\link{read_vcf}},
#' \code{\link{tidy_vcf}}.

#' @examples
#' \dontrun{
#' require(SeqVarTools)
#'
#' # blacklisting outliers individuals:
#' id.qc <- radiator::filter_individuals(
#'     data = "my.radiator.gds.rad",
#'     filter.individuals.missing = "outliers",
#'     filter.individuals.heterozygosity = "outliers",
#'     filter.individuals.coverage.total = "outliers")
#'
#' # using values to blacklist individuals:
#' id.qc <- radiator::filter_individuals(
#'     data = "my.radiator.gds.rad",
#'     filter.individuals.missing = 0.5,
#'     filter.individuals.heterozygosity = c(0.02, 0.03),
#'     filter.individuals.coverage.total = c(900000, 5000000))
#'
#' }

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}


filter_individuals <- function(
  data,
  interactive.filter = TRUE,
  filter.individuals.missing = NULL,
  filter.individuals.heterozygosity = NULL,
  # coverage.mean = NULL,
  filter.individuals.coverage.total = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = TRUE,
  ...
) {

  ##TESTS
  # path.folder <- NULL
  # parameters <- NULL
  # id.stats <- NULL
  # internal <- FALSE
  # dp <- TRUE
  # subsample <- NULL
  # subsample.markers.stats <- NULL
  # interactive.filter = TRUE
  # filter.individuals.missing = NULL
  # filter.individuals.heterozygosity = NULL
  # filter.individuals.coverage.total = NULL
  # parallel.core = parallel::detectCores() - 1
  # verbose = TRUE

  if (interactive.filter ||
      !is.null(filter.individuals.missing) ||
      !is.null(filter.individuals.heterozygosity) ||
      !is.null(filter.individuals.coverage.total)
  ) {
    if (interactive.filter) verbose <- TRUE
    if (verbose) {
      cat("################################################################################\n")
      cat("######################### radiator::filter_individuals #########################\n")
      cat("################################################################################\n")
    }
    # Cleanup---------------------------------------------------------------------
    file.date <- format(Sys.time(), "%Y%m%d@%H%M")
    if (verbose) message("Execution date@time: ", file.date)
    old.dir <- getwd()
    opt.change <- getOption("width")
    options(width = 70)
    timing <- proc.time()# for timing
    #back to the original directory and options
    on.exit(setwd(old.dir), add = TRUE)
    on.exit(options(width = opt.change), add = TRUE)
    on.exit(timing <- proc.time() - timing, add = TRUE)
    on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
    on.exit(if (verbose) cat("########################### completed filter_individuals #######################\n"), add = TRUE)

    # Function call and dotslist -------------------------------------------------
    rad.dots <- radiator_dots(
      func.name = as.list(sys.call())[[1]],
      fd = rlang::fn_fmls_names(),
      args.list = as.list(environment()),
      dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
      keepers = c("path.folder", "parameters", "internal", "id.stats", "dp",
                  "subsample", "subsample.markers.stats"),
      verbose = verbose
    )

    # Checking for missing and/or default arguments ----------------------------
    if (missing(data)) rlang::abort("data is missing")

    # Folders---------------------------------------------------------------------
    path.folder <- generate_folder(
      f = path.folder,
      rad.folder = "filter_individuals",
      internal = internal,
      file.date = file.date,
      verbose = verbose)

    # write the dots file
    write_rad(
      data = rad.dots,
      path = path.folder,
      filename = stringi::stri_join("radiator_filter_individuals_args_", file.date, ".tsv"),
      tsv = TRUE,
      internal = internal,
      verbose = verbose
    )

    # Message about steps taken during the process -----------------------------
    if (interactive.filter) {
      message("Interactive mode: on\n")
      message("Step 1. Visualization")
      message("Step 2. Missingness")
      message("Step 3. Heterozygosity")
      message("Step 4. Total Coverage (if available)\n\n")
    }

    # Detect format --------------------------------------------------------------
    data.type <- radiator::detect_genomic_format(data)

    # Import data ---------------------------------------------------------------
    if (!data.type %in% c("SeqVarGDSClass", "gds.file")) {
      rlang::abort("Input not supported for this function: read function documentation")
    }
    if (data.type == "gds.file") {
      data <- radiator::read_rad(data, verbose = verbose)
      data.type <- "SeqVarGDSClass"
    }
    if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"]) {
      rlang::abort('Please install SeqVarTools for this option:\n
         install.packages("BiocManager")
         BiocManager::install("SeqVarTools")')
    }


    # Filter parameter file: generate and initiate -------------------------------
    filters.parameters <- radiator_parameters(
      generate = TRUE,
      initiate = TRUE,
      update = FALSE,
      parameter.obj = parameters,
      data = data,
      path.folder = path.folder,
      file.date = file.date,
      internal = internal,
      verbose = verbose)

    # stats  ---------------------------------------------------------------------
    filter.monomorphic <- FALSE

    # Step 1. Visuals ----------------------------------------------------------
    if (interactive.filter) {
      message("\nStep 1. Visualization of samples QC\n")
    }

    # Note to myself: for now it's better not to subsample, because of filtering
    variant.select <- subsample <- NULL
    subsample.markers.stats <- 1

    id.stats <- generate_id_stats(
      gds = data,
      subsample = variant.select,
      path.folder = path.folder,
      file.date = file.date,
      parallel.core = parallel.core,
      verbose = verbose)
    print(id.stats$fig)

    # Step 2. Missingness-----------------------------------------------------------------
    if (interactive.filter) {
      message("\nStep 2. Filtering markers based individual missingness/genotyping\n")

      filter.individuals.missing <- radiator_question(
        x = "Do you want to blacklist samples based on missingness ? (y/n):",
        answer.opt = c("y", "n"))

      if (filter.individuals.missing == "y") {
        outlier.stats <- radiator_question(
          x = "Do you want to remove samples based on the outlier statistics or not (y/n) ?
(n: next question will be to enter your own threshold)", answer.opt = c("y", "n"))
        if (outlier.stats == "y") {
          filter.individuals.missing <- "outliers"
        } else {
          filter.individuals.missing <- radiator_question(
            x = "Enter the proportion threshold (0-1)
The maximum amount of missingness you tolerate for a sample:", minmax = c(0, 1))
        }
        outlier.stats <- NULL
      } else {
        filter.individuals.missing <- NULL
      }
    }
    if (!is.null(filter.individuals.missing)) {
      if (!purrr::is_double(filter.individuals.missing)) {
        # if max and outliers high are the same leave the value
        # if max and outliers high are not the same do gymnastic
        if (id.stats$stats$OUTLIERS_HIGH[1] == id.stats$stats$MAX[1]) {
          higher.eq <- FALSE
        } else {
          higher.eq <- TRUE
        }
        outlier.id.missing <- id.stats$stats$OUTLIERS_HIGH[1]
        if (verbose) message("\nRemoving outliers individuals based on genotyping statistics: ", outlier.id.missing)
        filter.individuals.missing <- outlier.id.missing
      } else {
        message("\nRemoving individuals based on genotyping statistics: ", filter.individuals.missing)
        higher.eq <- FALSE
      }

      bl <- dplyr::ungroup(id.stats$info)

      if (higher.eq) {
        bl %<>% dplyr::filter(MISSING_PROP >= filter.individuals.missing)
      } else {
        bl %<>% dplyr::filter(MISSING_PROP > filter.individuals.missing)
      }
      bl %<>%
        dplyr::distinct(INDIVIDUALS, .keep_all = TRUE) %>%
        dplyr::mutate(FILTER = "filter.individuals.missing")
      n.bl <- nrow(bl)

      individuals <- extract_individuals_metadata(gds = data, whitelist = FALSE) %>%
        dplyr::mutate(
          FILTERS = dplyr::if_else(
            INDIVIDUALS %in% bl$INDIVIDUALS,
            "filter.individuals.missing", FILTERS
          )
        )
      update_radiator_gds(
        gds = data, node.name = "individuals.meta", value = individuals, sync = TRUE)

      if (n.bl > 0) {
        filter.monomorphic <- TRUE
        bl.filename <- stringi::stri_join("blacklist.individuals.missing_", file.date, ".tsv")
        readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
      }

      # Filter parameter file: update
      filters.parameters <- radiator_parameters(
        generate = FALSE,
        initiate = FALSE,
        update = TRUE,
        parameter.obj = filters.parameters,
        data = data,
        filter.name = "Filter individuals based on missingness (with outlier stats or values)",
        param.name = "filter.individuals.missing",
        values = filter.individuals.missing,
        path.folder = path.folder,
        file.date = file.date,
        internal = internal,
        verbose = verbose)

      # results ------------------------------------------------------------------
      radiator_results_message(
        rad.message = stringi::stri_join("\nFilter individuals based on missingness: ",
                                         filter.individuals.missing),
        filters.parameters,
        internal,
        verbose
      )
    }#End filter.individuals.missing

    # Step 3. Heterozygosity------------------------------------------------------------
    if (interactive.filter) {
      message("\nStep 3. Filtering markers based on individual heterozygosity\n")

      filter.individuals.heterozygosity <- radiator_question(
        x = "Do you want to blacklist samples based on heterozygosity ? (y/n):",
        answer.opt = c("y", "n"))

      if (filter.individuals.heterozygosity == "y") {
        outlier.stats <- radiator_question(
          x = "Do you want to remove samples based on the outliers statistics or not (y/n) ?
(n: next questions will be to enter your own thresholds)", answer.opt = c("y", "n"))
        if (outlier.stats == "y") {
          filter.individuals.heterozygosity <- "outliers"
        } else {
          filter.individuals.heterozygosity <- c(0,1)
          filter.individuals.heterozygosity[1] <- radiator_question(
            x = "Enter the min proportion threshold (0-1)
The minimum amount of heterozygosity you tolerate for a sample:", minmax = c(0, 1))
          filter.individuals.heterozygosity[2] <- radiator_question(
            x = "Enter the max proportion threshold (0-1)
The maximum amount of heterozygosity you tolerate for a sample:", minmax = c(0, 1))
        }
        outlier.stats <- NULL
      } else {
        filter.individuals.heterozygosity <- NULL
      }
    }
    if (!is.null(filter.individuals.heterozygosity)) {
      if (length(filter.individuals.heterozygosity) > 1) {
        het.low <- filter.individuals.heterozygosity[1]
        het.high <- filter.individuals.heterozygosity[2]
        if (verbose) message("\nRemoving individuals based on heterozygosity statistics: ", het.low, " / ", het.high)
        higher.eq <- FALSE
        lower.eq <- FALSE
      } else {
        if (is.character(filter.individuals.heterozygosity)) {
          if (id.stats$stats$OUTLIERS_LOW[2] == id.stats$stats$MIN[2]) {
            lower.eq <- FALSE
          } else {
            lower.eq <- TRUE
          }
          if (id.stats$stats$OUTLIERS_HIGH[2] == id.stats$stats$MAX[2]) {
            higher.eq <- FALSE
          } else {
            higher.eq <- TRUE
          }
          het.low <- id.stats$stats$OUTLIERS_LOW[2]
          het.high <- id.stats$stats$OUTLIERS_HIGH[2]
          if (verbose) message("\nRemoving outliers individuals based on heterozygosity statistics: ", het.low, " / ", het.high)
        } else {
          rlang::abort("Unknown filter.individuals.heterozygosity thresholds used")
        }
      }

      bl <- dplyr::ungroup(id.stats$info)

      # fl & fh for filter high and low
      if (lower.eq) {
        fl <- "HETEROZYGOSITY <= het.low"
      } else {
        fl <- "HETEROZYGOSITY < het.low"
      }
      if (higher.eq) {
        fh <- "HETEROZYGOSITY >= het.high"
      } else {
        fh <- "HETEROZYGOSITY > het.high"
      }

      filter.het <- stringi::stri_join(fh, fl, sep = " | ")
      bl %<>%
        dplyr::filter(!!rlang::parse_expr(filter.het)) %>%
        dplyr::distinct(INDIVIDUALS) %>%
        dplyr::mutate(FILTER = "filter.individuals.heterozygosity")
      n.bl <- nrow(bl)

      individuals <- extract_individuals_metadata(gds = data, whitelist = FALSE) %>%
        dplyr::mutate(
          FILTERS = dplyr::if_else(
            INDIVIDUALS %in% bl$INDIVIDUALS,
            "filter.individuals.heterozygosity", FILTERS
          )
        )
      update_radiator_gds(gds = data, node.name = "individuals.meta", value = individuals, sync = TRUE)

      if (n.bl > 0) {
        filter.monomorphic <- TRUE

        if (verbose) message("    number of individuals blacklisted based on heterozygosity: ", n.bl)
        bl.filename <- stringi::stri_join("blacklist.individuals.heterozygosity_", file.date, ".tsv")
        readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
        # bl.i <- update_bl_individuals(gds = data, update = bl)
        id.stats$info  %<>%
          dplyr::filter(!INDIVIDUALS %in% bl$INDIVIDUALS)

        # update_radiator_gds(gds = data, node.name = "individuals.meta", value = id.stats$info, sync = TRUE)
      }
      # Filter parameter file: update
      filters.parameters <- radiator_parameters(
        generate = FALSE,
        initiate = FALSE,
        update = TRUE,
        parameter.obj = filters.parameters,
        data = data,
        filter.name = "Filter individuals based on heterozygosity (with outlier stats or values)",
        param.name = "filter.individuals.heterozygosity",
        values = paste(het.low, het.high, collapse = " / "),
        path.folder = path.folder,
        file.date = file.date,
        internal = internal,
        verbose = verbose)

      # results ------------------------------------------------------------------
      radiator_results_message(
        rad.message = stringi::stri_join("\nFilter individuals based on heterozygosity: ", paste(het.low, het.high, collapse = " / ")),
        filters.parameters,
        internal,
        verbose
      )
    }#End filter.individuals.heterozygosity

    # Step 4. Coverage total--------------------------------------------------------------
    if (dp) {
      if (interactive.filter) {
        message("\nStep 4. Filtering markers based on individual's total coverage\n")

        filter.individuals.coverage.total <- radiator_question(
          x = "Do you want to blacklist samples based on total coverage ? (y/n):",
          answer.opt = c("y", "n"))

        if (filter.individuals.coverage.total == "y") {
          outlier.stats <- radiator_question(
            x = "Do you want to remove samples based on the outliers statistics or not (y/n) ?
          (n: next questions will be to enter your own thresholds)", answer.opt = c("y", "n"))
          if (outlier.stats == "y") {
            filter.individuals.coverage.total <- "outliers"
          } else {
            filter.individuals.coverage.total <- c(0,10000000000000000000000)
            filter.individuals.coverage.total[1] <- radiator_question(
              x = "Enter the min proportion threshold (0-1)
            The minimum amount of coverage you tolerate for a sample:", minmax = c(0, 10000000000000000000000))
            filter.individuals.coverage.total[2] <- radiator_question(
              x = "Enter the max proportion threshold (0-1)
            The maximum amount of coverage you tolerate for a sample:", minmax = c(0, 10000000000000000000000))
          }
          outlier.stats <- NULL
        } else {
          filter.individuals.coverage.total <- NULL
        }
      }
      if (!is.null(filter.individuals.coverage.total)) {
        if (length(filter.individuals.coverage.total) > 1) {
          cov.low <- filter.individuals.coverage.total[1]
          cov.high <- filter.individuals.coverage.total[2]
          if (verbose) message("\nRemoving individuals based on total coverage statistics: ", cov.low, " / ", cov.high)
        } else {
          if (is.character(filter.individuals.coverage.total)) {
            if (id.stats$stats$OUTLIERS_LOW[3] == id.stats$stats$MIN[3]) {
              lower.eq <- FALSE
            } else {
              lower.eq <- TRUE
            }
            if (id.stats$stats$OUTLIERS_HIGH[3] == id.stats$stats$MAX[3]) {
              higher.eq <- FALSE
            } else {
              higher.eq <- TRUE
            }
            # cov.low <- floor(id.stats$stats$OUTLIERS_LOW[3]*1000)/1000
            # cov.high <- floor(id.stats$stats$OUTLIERS_HIGH[3]*1000)/1000
            cov.low <- id.stats$stats$OUTLIERS_LOW[3]
            cov.high <- id.stats$stats$OUTLIERS_HIGH[3]
            if (verbose) message("\nRemoving outliers individuals based on total coverage statistics: ", cov.low, " / ", cov.high)
            } else {
            rlang::abort("Unknown coverage total thresholds used")
          }
        }

        bl <- dplyr::ungroup(id.stats$info)

        # fl & fh for filter high and low
        if (lower.eq) {
          fl <- "COVERAGE_TOTAL <= cov.low"
        } else {
          fl <- "COVERAGE_TOTAL < cov.low"
        }
        if (higher.eq) {
          fh <- "COVERAGE_TOTAL >= cov.high"
        } else {
          fh <- "COVERAGE_TOTAL > cov.high"
        }

        filter.cov <- stringi::stri_join(fh, fl, sep = " | ")
        bl %<>%
          dplyr::filter(!!rlang::parse_expr(filter.cov)) %>%
          dplyr::distinct(INDIVIDUALS) %>%
          dplyr::mutate(FILTER = "filter.individuals.coverage.total")
        n.bl <- nrow(bl)

        individuals <- extract_individuals_metadata(gds = data, whitelist = FALSE) %>%
          dplyr::mutate(
            FILTERS = dplyr::if_else(
              INDIVIDUALS %in% bl$INDIVIDUALS,
              "filter.individuals.coverage.total", FILTERS
            )
          )
        update_radiator_gds(gds = data, node.name = "individuals.meta", value = individuals, sync = TRUE)

        if (n.bl > 0) {
          filter.monomorphic <- TRUE
          if (verbose) message("    number of individuals blacklisted based on total coverage: ", n.bl)
          bl.filename <- stringi::stri_join("blacklist.individuals.coverate.total_", file.date, ".tsv")
          readr::write_tsv(x = bl, path = file.path(path.folder, bl.filename))
          # bl.i <- update_bl_individuals(gds = data, update = bl)
          # id.stats$info  %<>%
          # dplyr::filter(!INDIVIDUALS %in% bl$INDIVIDUALS)

          # update_radiator_gds(gds = data, node.name = "individuals.meta", value = id.stats$info, sync = TRUE)
        }
        # Filter parameter file: update
        filters.parameters <- radiator_parameters(
          generate = FALSE,
          initiate = FALSE,
          update = TRUE,
          parameter.obj = filters.parameters,
          data = data,
          filter.name = "Filter individuals based on total coverage (with outlier stats or values)",
          param.name = "filter.individuals.coverage.total",
          values = paste(cov.low, cov.high, collapse = " / "),
          path.folder = path.folder,
          file.date = file.date,
          internal = internal,
          verbose = verbose)

        # results ------------------------------------------------------------------
        radiator_results_message(
          rad.message = stringi::stri_join("\nFilter individuals based on total coverage: ", paste(cov.low, cov.high, collapse = " / ")),
          filters.parameters,
          internal,
          verbose
        )
      }#End coverage total
    }

    # MONOMORPHIC MARKERS --------------------------------------------------
    data <- filter_monomorphic(
      data = data,
      filter.monomorphic = filter.monomorphic,
      parallel.core = parallel.core,
      verbose = FALSE,
      parameters = filters.parameters,
      path.folder = path.folder,
      internal = FALSE)
  }#before this one
  return(data)
}#End filter_individuals
