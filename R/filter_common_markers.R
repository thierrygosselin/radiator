# Keep markers in common between all populations

#' @name filter_common_markers

#' @title Filter common markers between strata

#' @description The function will filter the markers by keeping only those
#' in common between all strata
#' (population or any groupings defined in \code{STRATA/POP_ID} column).
#'
#' \strong{Filter targets}: SNPs
#'
#' \strong{Statistics}: strata genotyping rate per SNPs
#'
#'
#' Used internally in \href{https://github.com/thierrygosselin/radiator}{radiator}
#' and might be of interest for users who wants to keep only markers in common.


#' @param data (4 options) A file or object generated by radiator:
#' \itemize{
#' \item tidy data
#' \item Genomic Data Structure (GDS)
#' }
#'
#' \emph{How to get GDS and tidy data ?}
#' Look into \code{\link{tidy_genomic_data}},
#' \code{\link{write_seqarray}} or
#' \code{\link{tidy_vcf}}.
#'
#' @param filter.common.markers (optional, logical)
#' Default: \code{filter.common.markers = TRUE}.
#'
#' @param plot (optional, logical) \code{plot = TRUE} will produce an
#' \href{https://github.com/hms-dbmi/UpSetR}{UpSet plot} to visualize the number
#' of markers between populations. The package is required for this to work...
#' Default: \code{plot = FALSE}.

#' @param verbose (optional, logical) \code{verbose = TRUE} to be chatty
#' during execution.
#' Default: \code{verbose = FALSE}.
#' @param ... (optional) To pass further arguments for fine-tuning the function
#' and legacy arguments.
#' @inheritParams tidy_genomic_data

#' @return A list with the filtered input, whitelist and blacklist of markers..

#' @examples
#' \dontrun{
#' require(SeqVarTools) # when using gds
#' common <- radiator::filter_common_markers(data = "my.radiator.gds.rad", verbose = TRUE)
#' }

#' @export
#' @rdname filter_common_markers
#' @importFrom dplyr select mutate group_by ungroup rename tally filter semi_join n_distinct
#' @importFrom stringi stri_replace_all_fixed stri_join
#' @importFrom tibble has_name
# @importFrom UpSetR upset

#' @author Thierry Gosselin \email{thierrygosselin@@icloud.com}

filter_common_markers <- function(
  data,
  filter.common.markers = TRUE,
  plot = FALSE,
  parallel.core = parallel::detectCores() - 1,
  verbose = FALSE,
  ...
) {
  # Test
  # filter.common.markers = TRUE
  # plot = TRUE
  # parallel.core = parallel::detectCores() - 1
  # verbose = TRUE
  # path.folder <- NULL
  # parameters <- NULL
  # internal <- FALSE



  if (filter.common.markers) {
    if (verbose) {
      cat("################################################################################\n")
      cat("######################## radiator::filter_common_markers #######################\n")
      cat("################################################################################\n")
    }
    # Cleanup-------------------------------------------------------------------
    file.date <- format(Sys.time(), "%Y%m%d@%H%M")
    if (verbose) message("Execution date@time: ", file.date)
    old.dir <- getwd()
    opt.change <- getOption("width")
    options(width = 70)
    timing <- proc.time()# for timing
    #back to the original directory and options
    on.exit(setwd(old.dir), add = TRUE)
    on.exit(options(width = opt.change), add = TRUE)
    on.exit(timing <- proc.time() - timing, add = TRUE)
    on.exit(if (verbose) message("\nComputation time, overall: ", round(timing[[3]]), " sec"), add = TRUE)
    on.exit(if (verbose) cat("####################### filter_common_markers completed ########################\n"), add = TRUE)

    # message("\nKeeping only common markers between strata")

    # Checking for missing and/or default arguments ------------------------------
    if (missing(data)) rlang::abort("Input file missing")

    # Function call and dotslist -------------------------------------------------
    rad.dots <- radiator_dots(
      func.name = as.list(sys.call())[[1]],
      fd = rlang::fn_fmls_names(),
      args.list = as.list(environment()),
      dotslist = rlang::dots_list(..., .homonyms = "error", .check_assign = TRUE),
      keepers = c("path.folder", "parameters", "internal"),
      verbose = verbose
    )
    if (internal) plot <- FALSE
    if (plot) {
      if (!requireNamespace("UpSetR", quietly = TRUE)) {
        rlang::abort("UpSetR needed for this function to work
                   Install with install.packages('UpSetR')")
      }
    }
    # Folders---------------------------------------------------------------------
    path.folder <- generate_folder(
      f = path.folder,
      rad.folder = "filter_common_markers",
      internal = internal,
      file.date = file.date,
      verbose = verbose)

    # write the dots file
    write_rad(
      data = rad.dots,
      path = path.folder,
      filename = stringi::stri_join(
        "radiator_filter_common_markers_args_", file.date, ".tsv"),
      tsv = TRUE,
      internal = internal,
      verbose = verbose
    )

    # Detect format --------------------------------------------------------------
    data.type <- radiator::detect_genomic_format(data)
    if (!data.type %in% c("tbl_df", "fst.file", "SeqVarGDSClass", "gds.file")) {
      rlang::abort("Input not supported for this function: read function documentation")
    }


    # GDS
    if (data.type %in% c("SeqVarGDSClass", "gds.file")) {
      if (!"SeqVarTools" %in% utils::installed.packages()[,"Package"]) {
        rlang::abort('Please install SeqVarTools for this option:\n
           install.packages("BiocManager")
           BiocManager::install("SeqVarTools")')
      }

      if (data.type == "gds.file") {
        data <- radiator::read_rad(data, verbose = verbose)
        data.type <- "SeqVarGDSClass"
      }

      # Filter parameter file: generate and initiate -----------------------------
      filters.parameters <- radiator_parameters(
        generate = TRUE,
        initiate = TRUE,
        update = FALSE,
        parameter.obj = parameters,
        data = data,
        path.folder = path.folder,
        file.date = file.date,
        internal = FALSE,
        verbose = verbose)
      n.pop <- filters.parameters$info$n.pop

      if (plot && n.pop == 1) {
        message("\n\nNOTE: the plot argument requires more than 1 strata\n\n")
        plot <- FALSE
      }

      # Filtering common markers -------------------------------------------------
      if (verbose) message("Scanning for common markers...")
      wl <- bl <- extract_markers_metadata(gds = data)
      n.markers.before <- nrow(wl)
      strata <- extract_individuals(gds = data, ind.field.select = c("STRATA", "INDIVIDUALS"))

      if (plot) {
        plot.filename <- stringi::stri_join(
          "common.markers.upsetrplot_", file.date, ".pdf")
        plot.filename <- file.path(path.folder, plot.filename)
        plot_upset(x = data, data.type = data.type,
                   strata = strata,
                   plot.filename = plot.filename,
                   parallel.core = parallel.core,
                   n.pop = n.pop, verbose = verbose)
      }


      bl <- not_common_markers(x = data, strata = strata,
                               parallel.core = parallel.core)
      n.markers.removed <- length(bl)
      want <- c("VARIANT_ID", "MARKERS", "CHROM", "LOCUS", "POS")
      if (n.markers.removed > 0) {
        n.markers.after <- n.markers.before - n.markers.removed
        bl <- wl %>% dplyr::filter(VARIANT_ID %in% bl) %>%
          dplyr::select(dplyr::one_of(want))

        write_rad(
          data = bl,
          path = path.folder,
          filename = stringi::stri_join("blacklist.not.common.markers_", file.date, ".tsv"),
          tsv = TRUE, internal = FALSE, verbose = verbose)

        wl %<>% dplyr::filter(!MARKERS %in% bl$MARKERS)


        # Update GDS
        update_radiator_gds(
          gds = data,
          node.name = "markers.meta",
          value = wl,
          sync = TRUE
        )
        # radiator::sync_gds(gds = data, markers = wl$VARIANT_ID, verbose = FALSE)
        #
        # radiator.gds <- gdsfmt::index.gdsn(
        #   node = data, path = "radiator", silent = TRUE)
        #
        # # Update metadata
        # gdsfmt::add.gdsn(
        #   node = radiator.gds,
        #   name = "markers.meta",
        #   val = wl,
        #   replace = TRUE,
        #   compress = "ZIP_RA",
        #   closezip = TRUE)

        # update blacklist.markers
        bl %<>% dplyr::select(MARKERS) %>%
          dplyr::mutate(FILTER = "filter.common.markers")
        bl.gds <- update_bl_markers(gds = data, update = bl)
      } else {
        bl <- wl[0,]
        n.markers.after <- n.markers.before
      }
      # write the whitelist even if no blacklist...
      write_rad(
        data = wl,
        path = path.folder,
        filename = stringi::stri_join("whitelist.common.markers_", file.date, ".tsv"),
        tsv = TRUE, internal = FALSE, verbose = verbose)

    } else {#Tidy data
      # Import data ---------------------------------------------------------------
      if (is.vector(data)) data <- radiator::tidy_wide(data = data, import.metadata = TRUE)

      # Keep whitelist and blacklist (same = same space used)
      wl <- radiator::separate_markers(data = data, sep = "__", markers.meta.lists.only = TRUE)

      data %<>% dplyr::left_join(wl, by = intersect(colnames(data), colnames(wl)))


      # Filter parameter file: generate and initiate ------------------------------------------
      filters.parameters <- radiator_parameters(
        generate = TRUE,
        initiate = TRUE,
        update = FALSE,
        parameter.obj = parameters,
        data = data,
        path.folder = path.folder,
        file.date = file.date,
        internal = FALSE,
        verbose = verbose)

      n.pop <- filters.parameters$info$n.pop
      if (plot && n.pop == 1) {
        message("\n\nNOTE: the plot argument requires more than 1 strata\n\n")
        plot <- FALSE
      }
      if (plot) {
        plot.filename <- stringi::stri_join(
          "common.markers.upsetrplot_", file.date, ".pdf")
        plot.filename <- file.path(path.folder, plot.filename)
        plot_upset(x = data,
                   data.type = data.type,
                   n.pop = n.pop,
                   plot.filename = plot.filename,
                   parallel.core = parallel.core
        )
      }

      if (verbose) message("Scanning for common markers...")

      if (tibble::has_name(data, "GT_BIN")) {
        bl <- dplyr::select(.data = data, MARKERS, POP_ID, GT_BIN) %>%
          dplyr::filter(!is.na(GT_BIN))
      } else {
        bl <- dplyr::select(.data = data, MARKERS, POP_ID, GT) %>%
          dplyr::filter(GT != "000000")
      }

      bl <- dplyr::distinct(bl, MARKERS, POP_ID) %>%
        dplyr::count(x = ., MARKERS) %>%
        dplyr::filter(n != length(unique(data$POP_ID))) %>%
        dplyr::distinct(MARKERS) %>%
        dplyr::arrange(MARKERS)

      # Remove the markers from the dataset
      n.markers.removed <- nrow(bl)

      if (n.markers.removed > 0) {
        data <- dplyr::filter(data, !MARKERS %in% bl$MARKERS)
        bl <- wl %>% dplyr::filter(MARKERS %in% bl$MARKERS)
        write_rad(
          data = bl,
          path = path.folder,
          filename = stringi::stri_join("blacklist.not.common.markers_", file.date, ".tsv"),
          tsv = TRUE, internal = FALSE, verbose = verbose)

        wl %<>% dplyr::filter(!MARKERS %in% bl$MARKERS)
        write_rad(
          data = wl,
          path = path.folder,
          filename = stringi::stri_join("whitelist.common.markers_", file.date, ".tsv"),
          tsv = TRUE, internal = FALSE, verbose = verbose)
      } else {
        bl <- wl[0,]
      }


    }#End tidy

    # Filter parameter file: update --------------------------------------------
    filters.parameters <- radiator_parameters(
      generate = FALSE,
      initiate = FALSE,
      update = TRUE,
      parameter.obj = filters.parameters,
      data = data,
      filter.name = "Filter markers in common",
      param.name = "filter.common.markers",
      values = "",
      path.folder = path.folder,
      file.date = file.date,
      internal = FALSE,
      verbose = verbose)

    # Return -----------------------------------------------------------------------
      if (verbose) cat("################################### RESULTS ####################################\n")
      message("\nFilter common markers:")
      message("Number of individuals / strata / chrom / locus / SNP:")
      if (verbose) message("    Before: ", filters.parameters$filters.parameters$BEFORE)
      message("    Blacklisted: ", filters.parameters$filters.parameters$BLACKLIST)
      if (verbose) message("    After: ", filters.parameters$filters.parameters$AFTER)
  }
  return(data)

}#End filter_common_markers

# Internal functions -----------------------------------------------------------
# Generate a blacklist of markers not in common
#' @title not_common_markers
#' @description Generate a blacklist of markers not in common
#' @rdname not_common_markers
#' @keywords internal
#' @export
not_common_markers <- function(
  x,
  strata,
  parallel.core = parallel::detectCores() - 1
) {

  # Get the sample from radiator node or gds -----------------------------------
  sample.bk <- gdsfmt::index.gdsn(
    node = x, path = "radiator/individuals/INDIVIDUALS", silent = TRUE)

  if (!is.null(sample.bk)) {
    sample.bk <- gdsfmt::read.gdsn(sample.bk)
  } else {
    sample.bk <- SeqArray::seqGetData(x, "sample.id")
  }

  not_common <- function(
    id.select, x, parallel.core = parallel::detectCores() - 1
  ) {

    SeqArray::seqSetFilter(object = x,
                           sample.id = id.select$INDIVIDUALS,
                           action = "set",
                           verbose = FALSE)

    bl <- SeqArray::seqGetData(
      gdsfile = x,
      var.name = "variant.id")[SeqArray::seqMissing(
        gdsfile = x, per.variant = TRUE,
        .progress = TRUE,
        parallel = parallel.core
      ) == 1]
    return(bl)
  }#End not_common

  bl <- split(x = strata, f = strata$STRATA) %>%
    purrr::map(.x = .,
               .f = not_common,
               x = x, parallel.core = parallel.core
    ) %>% unlist %>% unique %>% sort

  # reset
  SeqArray::seqSetFilter(object = x,
                         sample.id = sample.bk,
                         action = "set",
                         verbose = FALSE)
  return(bl)
}#End missing_per_pop

# Generate UPSETR plot----------------------------------------------------------
#' @title plot_upset
#' @description Generate UpSetR plot
#' @rdname plot_upset
#' @keywords internal
#' @export

plot_upset <- function(
  x,
  data.type,
  n.pop = 1L,
  strata = NULL,
  plot.filename = NULL,
  parallel.core = parallel::detectCores() - 1,
  verbose = FALSE
) {

  if (data.type == "SeqVarGDSClass") {
    # Get the sample from radiator node or gds -----------------------------
    sample.bk <- gdsfmt::index.gdsn(
      node = x, path = "radiator/individuals/INDIVIDUALS", silent = TRUE)

    if (!is.null(sample.bk)) {
      sample.bk <- gdsfmt::read.gdsn(sample.bk)
    } else {
      sample.bk <- SeqArray::seqGetData(x, "sample.id")
    }

    missing_markers_pop <- function(
      id.select, x, parallel.core = parallel::detectCores() - 1
    ) {
      SeqArray::seqSetFilter(object = x,
                             sample.id = id.select$INDIVIDUALS,
                             action = "set",
                             verbose = FALSE)
      # message("Strata: ", unique(id.select$STRATA))

      res <- tibble::tibble(
        STRATA = SeqArray::seqMissing(
          gdsfile = x, per.variant = TRUE,
          .progress = TRUE,
          parallel = parallel.core
        ) %>%
          magrittr::inset(. == 1L, 9L) %>%
          magrittr::inset(. < 1L, 1L) %>%
          magrittr::inset(. == 9L, 0L)
      ) %>%
        magrittr::set_colnames(., unique(id.select$STRATA))
      return(res)
    }#End not_common

    plot.data <- split(x = strata, f = strata$STRATA) %>%
      purrr::map_dfc(
        .x = .,
        .f = missing_markers_pop,
        x = x,
        parallel.core = parallel.core
      ) %>%
      data.frame(.)

    # reset
    SeqArray::seqSetFilter(object = x,
                           sample.id = sample.bk,
                           action = "set",
                           verbose = FALSE)

  } else {
    if (tibble::has_name(x, "GT_BIN")) {
      plot.data <- dplyr::filter(x, !is.na(GT_BIN))
    } else {
      plot.data <- dplyr::filter(x, GT != "000000")
    }

    plot.data <- dplyr::distinct(plot.data, MARKERS, POP_ID) %>%
      dplyr::mutate(
        n = rep(1, n()),
        POP_ID = stringi::stri_join("POP_", POP_ID)
      ) %>%
      tidyr::spread(data = ., key = POP_ID, value = n, fill = 0) %>%
      data.frame(.)
  }

  pdf(file = plot.filename, onefile = FALSE)
  UpSetR::upset(plot.data, nsets = n.pop,
                order.by = "freq", empty.intersections = NULL)
  dev.off()
  if (verbose) message("    UpSet plot generated to visualize markers in common")
}#End plot_upset
